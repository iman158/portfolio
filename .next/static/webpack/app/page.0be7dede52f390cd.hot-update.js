/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/background-animations.tsx":
/*!**************************************************!*\
  !*** ./src/components/background-animations.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BackgroundAnimations)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _cyber_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cyber-grid */ \"(app-pages-browser)/./src/components/cyber-grid.tsx\");\n/* harmony import */ var _cyber_grid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cyber_grid__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction BackgroundAnimations() {\n    _s();\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isLowPerformance, setIsLowPerformance] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    // Performance detection and optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"BackgroundAnimations.useEffect\": ()=>{\n            setMounted(true);\n            // Detect low performance devices\n            const checkPerformance = {\n                \"BackgroundAnimations.useEffect.checkPerformance\": ()=>{\n                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n                    const isLowMemory = navigator.deviceMemory && navigator.deviceMemory < 4;\n                    const isSlowConnection = navigator.connection && navigator.connection.effectiveType === \"slow-2g\";\n                    setIsLowPerformance(isMobile || isLowMemory || isSlowConnection);\n                }\n            }[\"BackgroundAnimations.useEffect.checkPerformance\"];\n            checkPerformance();\n        }\n    }[\"BackgroundAnimations.useEffect\"], []);\n    if (!mounted) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 z-0 overflow-hidden pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_cyber_grid__WEBPACK_IMPORTED_MODULE_1___default()), {\n            isLowPerformance: isLowPerformance\n        }, void 0, false, {\n            fileName: \"D:\\\\portfolio\\\\src\\\\components\\\\background-animations.tsx\",\n            lineNumber: 31,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\portfolio\\\\src\\\\components\\\\background-animations.tsx\",\n        lineNumber: 30,\n        columnNumber: 5\n    }, this);\n}\n_s(BackgroundAnimations, \"2n8FmAaO3gXdl54jKtJ7hRMKLGw=\");\n_c = BackgroundAnimations;\nvar _c;\n$RefreshReg$(_c, \"BackgroundAnimations\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2JhY2tncm91bmQtYW5pbWF0aW9ucy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFb0M7QUFDTztBQUU1QixTQUFTRzs7SUFDdEIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdKLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ0ssa0JBQWtCQyxvQkFBb0IsR0FBR04sK0NBQVFBLENBQUM7SUFFekQseUNBQXlDO0lBQ3pDQyxnREFBU0E7MENBQUM7WUFDUkcsV0FBVztZQUVYLGlDQUFpQztZQUNqQyxNQUFNRzttRUFBbUI7b0JBQ3ZCLE1BQU1DLFdBQVcsaUVBQWlFQyxJQUFJLENBQUNDLFVBQVVDLFNBQVM7b0JBQzFHLE1BQU1DLGNBQWMsVUFBbUJDLFlBQVksSUFBSSxVQUFtQkEsWUFBWSxHQUFHO29CQUN6RixNQUFNQyxtQkFDSixVQUFtQkMsVUFBVSxJQUFJLFVBQW1CQSxVQUFVLENBQUNDLGFBQWEsS0FBSztvQkFFbkZWLG9CQUFvQkUsWUFBWUksZUFBZUU7Z0JBQ2pEOztZQUVBUDtRQUNGO3lDQUFHLEVBQUU7SUFFTCxJQUFJLENBQUNKLFNBQVMsT0FBTztJQUVyQixxQkFDRSw4REFBQ2M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ25CLG9EQUFTQTtZQUFDTSxrQkFBa0JBOzs7Ozs7Ozs7OztBQUduQztHQTVCd0JIO0tBQUFBIiwic291cmNlcyI6WyJEOlxccG9ydGZvbGlvXFxzcmNcXGNvbXBvbmVudHNcXGJhY2tncm91bmQtYW5pbWF0aW9ucy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCBDeWJlckdyaWQgZnJvbSBcIi4vY3liZXItZ3JpZFwiXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmFja2dyb3VuZEFuaW1hdGlvbnMoKSB7XHJcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgW2lzTG93UGVyZm9ybWFuY2UsIHNldElzTG93UGVyZm9ybWFuY2VdID0gdXNlU3RhdGUoZmFsc2UpXHJcblxyXG4gIC8vIFBlcmZvcm1hbmNlIGRldGVjdGlvbiBhbmQgb3B0aW1pemF0aW9uXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldE1vdW50ZWQodHJ1ZSlcclxuXHJcbiAgICAvLyBEZXRlY3QgbG93IHBlcmZvcm1hbmNlIGRldmljZXNcclxuICAgIGNvbnN0IGNoZWNrUGVyZm9ybWFuY2UgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlzTW9iaWxlID0gL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXHJcbiAgICAgIGNvbnN0IGlzTG93TWVtb3J5ID0gKG5hdmlnYXRvciBhcyBhbnkpLmRldmljZU1lbW9yeSAmJiAobmF2aWdhdG9yIGFzIGFueSkuZGV2aWNlTWVtb3J5IDwgNFxyXG4gICAgICBjb25zdCBpc1Nsb3dDb25uZWN0aW9uID1cclxuICAgICAgICAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbiAmJiAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlID09PSBcInNsb3ctMmdcIlxyXG5cclxuICAgICAgc2V0SXNMb3dQZXJmb3JtYW5jZShpc01vYmlsZSB8fCBpc0xvd01lbW9yeSB8fCBpc1Nsb3dDb25uZWN0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrUGVyZm9ybWFuY2UoKVxyXG4gIH0sIFtdKVxyXG5cclxuICBpZiAoIW1vdW50ZWQpIHJldHVybiBudWxsXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgei0wIG92ZXJmbG93LWhpZGRlbiBwb2ludGVyLWV2ZW50cy1ub25lXCI+XHJcbiAgICAgIDxDeWJlckdyaWQgaXNMb3dQZXJmb3JtYW5jZT17aXNMb3dQZXJmb3JtYW5jZX0gLz5cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsiQ3liZXJHcmlkIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJCYWNrZ3JvdW5kQW5pbWF0aW9ucyIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwiaXNMb3dQZXJmb3JtYW5jZSIsInNldElzTG93UGVyZm9ybWFuY2UiLCJjaGVja1BlcmZvcm1hbmNlIiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNMb3dNZW1vcnkiLCJkZXZpY2VNZW1vcnkiLCJpc1Nsb3dDb25uZWN0aW9uIiwiY29ubmVjdGlvbiIsImVmZmVjdGl2ZVR5cGUiLCJkaXYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/background-animations.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/cyber-grid.tsx":
/*!***************************************!*\
  !*** ./src/components/cyber-grid.tsx ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// \"use client\"\n// import { useEffect, useRef, useCallback } from \"react\"\n// interface CyberGridProps {\n//   isLowPerformance?: boolean\n// }\n// interface Particle {\n//   x: number\n//   y: number\n//   size: number\n//   speedX: number\n//   speedY: number\n//   opacity: number\n//   connection: number\n// }\n// interface Connection {\n//   from: number\n//   to: number\n//   life: number\n//   maxLife: number\n// }\n// export default function CyberGrid({ isLowPerformance = false }: CyberGridProps) {\n//   const canvasRef = useRef<HTMLCanvasElement>(null)\n//   const animationIdRef = useRef<number>()\n//   const particlesRef = useRef<Particle[]>([])\n//   const connectionsRef = useRef<Connection[]>([])\n//   const mouseRef = useRef({ x: 0, y: 0, active: false })\n//   // Performance-based configuration\n//   const config = {\n//     particleCount: isLowPerformance ? 30 : 60,\n//     gridSize: isLowPerformance ? 40 : 30,\n//     particleSize: isLowPerformance ? { min: 1, max: 2 } : { min: 1, max: 3 },\n//     connectionDistance: isLowPerformance ? 150 : 200,\n//     connectionMaxCount: isLowPerformance ? 2 : 3,\n//     fadeOpacity: isLowPerformance ? 0.2 : 0.1,\n//     maxFPS: isLowPerformance ? 30 : 60,\n//     particleSpeed: isLowPerformance ? 0.3 : 0.5,\n//     mouseInfluenceRadius: 150,\n//     mouseInfluenceStrength: 0.5,\n//   }\n//   const initParticles = useCallback(\n//     (canvas: HTMLCanvasElement) => {\n//       particlesRef.current = []\n//       for (let i = 0; i < config.particleCount; i++) {\n//         particlesRef.current.push({\n//           x: Math.random() * canvas.width,\n//           y: Math.random() * canvas.height,\n//           size: Math.random() * (config.particleSize.max - config.particleSize.min) + config.particleSize.min,\n//           speedX: (Math.random() - 0.5) * config.particleSpeed,\n//           speedY: (Math.random() - 0.5) * config.particleSpeed,\n//           opacity: Math.random() * 0.5 + 0.2,\n//           connection: Math.floor(Math.random() * config.connectionMaxCount),\n//         })\n//       }\n//       connectionsRef.current = []\n//     },\n//     [config.connectionMaxCount],\n//   )\n//   const drawGrid = useCallback(\n//     (ctx: CanvasRenderingContext2D, width: number, height: number) => {\n//       ctx.strokeStyle = \"rgba(0, 255, 0, 0.1)\"\n//       ctx.lineWidth = 0.5\n//       // Draw vertical lines\n//       for (let x = 0; x <= width; x += config.gridSize) {\n//         ctx.beginPath()\n//         ctx.moveTo(x, 0)\n//         ctx.lineTo(x, height)\n//         ctx.stroke()\n//       }\n//       // Draw horizontal lines\n//       for (let y = 0; y <= height; y += config.gridSize) {\n//         ctx.beginPath()\n//         ctx.moveTo(0, y)\n//         ctx.lineTo(width, y)\n//         ctx.stroke()\n//       }\n//     },\n//     [config.gridSize],\n//   )\n//   const updateConnections = useCallback(() => {\n//     const particles = particlesRef.current\n//     const connections = connectionsRef.current\n//     // Update existing connections\n//     for (let i = connections.length - 1; i >= 0; i--) {\n//       connections[i].life--\n//       if (connections[i].life <= 0) {\n//         connections.splice(i, 1)\n//       }\n//     }\n//     // Create new connections\n//     for (let i = 0; i < particles.length; i++) {\n//       const p1 = particles[i]\n//       // Count current connections for this particle\n//       const currentConnections = connections.filter((c) => c.from === i || c.to === i).length\n//       if (currentConnections < p1.connection) {\n//         for (let j = i + 1; j < particles.length; j++) {\n//           const p2 = particles[j]\n//           const dx = p1.x - p2.x\n//           const dy = p1.y - p2.y\n//           const distance = Math.sqrt(dx * dx + dy * dy)\n//           if (distance < config.connectionDistance) {\n//             // Check if this connection already exists\n//             const connectionExists = connections.some(\n//               (c) => (c.from === i && c.to === j) || (c.from === j && c.to === i),\n//             )\n//             if (!connectionExists) {\n//               const maxLife = Math.floor(Math.random() * 200) + 100\n//               connections.push({\n//                 from: i,\n//                 to: j,\n//                 life: maxLife,\n//                 maxLife: maxLife,\n//               })\n//               break\n//             }\n//           }\n//         }\n//       }\n//     }\n//   }, [config.connectionDistance])\n//   const animate = useCallback(\n//     (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => {\n//       let lastTime = 0\n//       const targetFrameTime = 1000 / config.maxFPS\n//       const frame = (currentTime: number) => {\n//         if (currentTime - lastTime < targetFrameTime) {\n//           animationIdRef.current = requestAnimationFrame(frame)\n//           return\n//         }\n//         lastTime = currentTime\n//         // Clear canvas with fade effect\n//         ctx.fillStyle = `rgba(0, 0, 0, ${config.fadeOpacity})`\n//         ctx.fillRect(0, 0, canvas.width, canvas.height)\n//         // Draw grid\n//         drawGrid(ctx, canvas.width, canvas.height)\n//         // Update and draw connections\n//         updateConnections()\n//         const connections = connectionsRef.current\n//         const particles = particlesRef.current\n//         // Draw connections\n//         for (const connection of connections) {\n//           const p1 = particles[connection.from]\n//           const p2 = particles[connection.to]\n//           const alpha = (connection.life / connection.maxLife) * 0.8\n//           ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`\n//           ctx.lineWidth = 1\n//           ctx.beginPath()\n//           ctx.moveTo(p1.x, p1.y)\n//           ctx.lineTo(p2.x, p2.y)\n//           ctx.stroke()\n//           // Draw data packet moving along the connection\n//           const progress = 1 - connection.life / connection.maxLife\n//           const packetX = p1.x + (p2.x - p1.x) * progress\n//           const packetY = p1.y + (p2.y - p1.y) * progress\n//           ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 2})`\n//           ctx.beginPath()\n//           ctx.arc(packetX, packetY, 2, 0, Math.PI * 2)\n//           ctx.fill()\n//         }\n//         // Update and draw particles\n//         for (let i = 0; i < particles.length; i++) {\n//           const p = particles[i]\n//           // Apply mouse influence if active\n//           if (mouseRef.current.active) {\n//             const dx = mouseRef.current.x - p.x\n//             const dy = mouseRef.current.y - p.y\n//             const distance = Math.sqrt(dx * dx + dy * dy)\n//             if (distance < config.mouseInfluenceRadius) {\n//               const force = (config.mouseInfluenceRadius - distance) / config.mouseInfluenceRadius\n//               p.speedX += dx * force * config.mouseInfluenceStrength * 0.01\n//               p.speedY += dy * force * config.mouseInfluenceStrength * 0.01\n//             }\n//           }\n//           // Apply speed limits\n//           const maxSpeed = 2\n//           const speed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY)\n//           if (speed > maxSpeed) {\n//             p.speedX = (p.speedX / speed) * maxSpeed\n//             p.speedY = (p.speedY / speed) * maxSpeed\n//           }\n//           // Update position\n//           p.x += p.speedX\n//           p.y += p.speedY\n//           // Boundary check with bounce\n//           if (p.x < 0) {\n//             p.x = 0\n//             p.speedX *= -1\n//           } else if (p.x > canvas.width) {\n//             p.x = canvas.width\n//             p.speedX *= -1\n//           }\n//           if (p.y < 0) {\n//             p.y = 0\n//             p.speedY *= -1\n//           } else if (p.y > canvas.height) {\n//             p.y = canvas.height\n//             p.speedY *= -1\n//           }\n//           // Apply friction\n//           p.speedX *= 0.99\n//           p.speedY *= 0.99\n//           // Draw particle\n//           const size = p.size\n//           const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2)\n//           gradient.addColorStop(0, `rgba(0, 255, 0, ${p.opacity})`)\n//           gradient.addColorStop(1, \"rgba(0, 255, 0, 0)\")\n//           ctx.fillStyle = gradient\n//           ctx.beginPath()\n//           ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2)\n//           ctx.fill()\n//           // Core of the particle\n//           ctx.fillStyle = `rgba(0, 255, 0, ${p.opacity * 2})`\n//           ctx.beginPath()\n//           ctx.arc(p.x, p.y, size, 0, Math.PI * 2)\n//           ctx.fill()\n//         }\n//         animationIdRef.current = requestAnimationFrame(frame)\n//       }\n//       animationIdRef.current = requestAnimationFrame(frame)\n//     },\n//     [config, drawGrid, updateConnections],\n//   )\n//   useEffect(() => {\n//     const canvas = canvasRef.current\n//     if (!canvas) return\n//     const ctx = canvas.getContext(\"2d\")\n//     if (!ctx) return\n//     // Set canvas dimensions to window size\n//     const resizeCanvas = () => {\n//       const dpr = isLowPerformance ? 1 : window.devicePixelRatio || 1\n//       const rect = canvas.getBoundingClientRect()\n//       canvas.width = rect.width * dpr\n//       canvas.height = rect.height * dpr\n//       canvas.style.width = rect.width + \"px\"\n//       canvas.style.height = rect.height + \"px\"\n//       ctx.scale(dpr, dpr)\n//       initParticles(canvas)\n//     }\n//     // Mouse interaction\n//     const handleMouseMove = (e: MouseEvent) => {\n//       const rect = canvas.getBoundingClientRect()\n//       mouseRef.current = {\n//         x: e.clientX - rect.left,\n//         y: e.clientY - rect.top,\n//         active: true,\n//       }\n//     }\n//     const handleMouseLeave = () => {\n//       mouseRef.current.active = false\n//     }\n//     canvas.addEventListener(\"mousemove\", handleMouseMove)\n//     canvas.addEventListener(\"mouseleave\", handleMouseLeave)\n//     canvas.addEventListener(\"mouseenter\", () => {\n//       mouseRef.current.active = true\n//     })\n//     // Touch interaction for mobile\n//     const handleTouchMove = (e: TouchEvent) => {\n//       if (e.touches.length > 0) {\n//         const rect = canvas.getBoundingClientRect()\n//         mouseRef.current = {\n//           x: e.touches[0].clientX - rect.left,\n//           y: e.touches[0].clientY - rect.top,\n//           active: true,\n//         }\n//       }\n//     }\n//     const handleTouchEnd = () => {\n//       mouseRef.current.active = false\n//     }\n//     canvas.addEventListener(\"touchmove\", handleTouchMove)\n//     canvas.addEventListener(\"touchend\", handleTouchEnd)\n//     resizeCanvas()\n//     animate(canvas, ctx)\n//     // Throttled resize handler\n//     let resizeTimeout: NodeJS.Timeout\n//     const handleResize = () => {\n//       clearTimeout(resizeTimeout)\n//       resizeTimeout = setTimeout(resizeCanvas, 250)\n//     }\n//     window.addEventListener(\"resize\", handleResize)\n//     return () => {\n//       if (animationIdRef.current) {\n//         cancelAnimationFrame(animationIdRef.current)\n//       }\n//       clearTimeout(resizeTimeout)\n//       window.removeEventListener(\"resize\", handleResize)\n//       canvas.removeEventListener(\"mousemove\", handleMouseMove)\n//       canvas.removeEventListener(\"mouseleave\", handleMouseLeave)\n//       canvas.removeEventListener(\"touchmove\", handleTouchMove)\n//       canvas.removeEventListener(\"touchend\", handleTouchEnd)\n//     }\n//   }, [animate, initParticles, isLowPerformance])\n//   return (\n//     <canvas\n//       ref={canvasRef}\n//       className=\"fixed inset-0 z-0 w-full h-full\"\n//       style={{\n//         width: \"100vw\",\n//         height: \"100vh\",\n//         willChange: \"transform\",\n//         pointerEvents: \"auto\", // Enable mouse interaction\n//       }}\n//     />\n//   )\n// }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2N5YmVyLWdyaWQudHN4IiwibWFwcGluZ3MiOiJBQUFBLGVBQWU7QUFFZix5REFBeUQ7QUFFekQsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixJQUFJO0FBRUosdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixJQUFJO0FBRUoseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixJQUFJO0FBRUosb0ZBQW9GO0FBQ3BGLHNEQUFzRDtBQUN0RCw0Q0FBNEM7QUFDNUMsZ0RBQWdEO0FBQ2hELG9EQUFvRDtBQUNwRCwyREFBMkQ7QUFFM0QsdUNBQXVDO0FBQ3ZDLHFCQUFxQjtBQUNyQixpREFBaUQ7QUFDakQsNENBQTRDO0FBQzVDLGdGQUFnRjtBQUNoRix3REFBd0Q7QUFDeEQsb0RBQW9EO0FBQ3BELGlEQUFpRDtBQUNqRCwwQ0FBMEM7QUFDMUMsbURBQW1EO0FBQ25ELGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMsTUFBTTtBQUVOLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsa0NBQWtDO0FBQ2xDLHlEQUF5RDtBQUN6RCxzQ0FBc0M7QUFDdEMsNkNBQTZDO0FBQzdDLDhDQUE4QztBQUM5QyxpSEFBaUg7QUFDakgsa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxnREFBZ0Q7QUFDaEQsK0VBQStFO0FBQy9FLGFBQWE7QUFDYixVQUFVO0FBQ1Ysb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVCxtQ0FBbUM7QUFDbkMsTUFBTTtBQUVOLGtDQUFrQztBQUNsQywwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELDRCQUE0QjtBQUU1QiwrQkFBK0I7QUFDL0IsNERBQTREO0FBQzVELDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0Is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QUNyQixzQ0FBc0M7QUFDdEMsdURBQXVEO0FBQ3ZELFVBQVU7QUFDVixvQ0FBb0M7QUFDcEMsMkRBQTJEO0FBQzNELGlFQUFpRTtBQUNqRSxtRUFBbUU7QUFDbkUsaUVBQWlFO0FBQ2pFLCtEQUErRDtBQUMvRCxRQUFRO0FBQ1IsbURBQW1EO0FBRW5ELGFBQWE7QUFDYixjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLG9EQUFvRDtBQUNwRCxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsNkRBQTZEO0FBQzdELFdBQVc7QUFDWCxTQUFTO0FBQ1QsTUFBTTtBQUNOLElBQUkiLCJzb3VyY2VzIjpbIkQ6XFxwb3J0Zm9saW9cXHNyY1xcY29tcG9uZW50c1xcY3liZXItZ3JpZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gXCJ1c2UgY2xpZW50XCJcclxuXHJcbi8vIGltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG4vLyBpbnRlcmZhY2UgQ3liZXJHcmlkUHJvcHMge1xyXG4vLyAgIGlzTG93UGVyZm9ybWFuY2U/OiBib29sZWFuXHJcbi8vIH1cclxuXHJcbi8vIGludGVyZmFjZSBQYXJ0aWNsZSB7XHJcbi8vICAgeDogbnVtYmVyXHJcbi8vICAgeTogbnVtYmVyXHJcbi8vICAgc2l6ZTogbnVtYmVyXHJcbi8vICAgc3BlZWRYOiBudW1iZXJcclxuLy8gICBzcGVlZFk6IG51bWJlclxyXG4vLyAgIG9wYWNpdHk6IG51bWJlclxyXG4vLyAgIGNvbm5lY3Rpb246IG51bWJlclxyXG4vLyB9XHJcblxyXG4vLyBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XHJcbi8vICAgZnJvbTogbnVtYmVyXHJcbi8vICAgdG86IG51bWJlclxyXG4vLyAgIGxpZmU6IG51bWJlclxyXG4vLyAgIG1heExpZmU6IG51bWJlclxyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDeWJlckdyaWQoeyBpc0xvd1BlcmZvcm1hbmNlID0gZmFsc2UgfTogQ3liZXJHcmlkUHJvcHMpIHtcclxuLy8gICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpXHJcbi8vICAgY29uc3QgYW5pbWF0aW9uSWRSZWYgPSB1c2VSZWY8bnVtYmVyPigpXHJcbi8vICAgY29uc3QgcGFydGljbGVzUmVmID0gdXNlUmVmPFBhcnRpY2xlW10+KFtdKVxyXG4vLyAgIGNvbnN0IGNvbm5lY3Rpb25zUmVmID0gdXNlUmVmPENvbm5lY3Rpb25bXT4oW10pXHJcbi8vICAgY29uc3QgbW91c2VSZWYgPSB1c2VSZWYoeyB4OiAwLCB5OiAwLCBhY3RpdmU6IGZhbHNlIH0pXHJcblxyXG4vLyAgIC8vIFBlcmZvcm1hbmNlLWJhc2VkIGNvbmZpZ3VyYXRpb25cclxuLy8gICBjb25zdCBjb25maWcgPSB7XHJcbi8vICAgICBwYXJ0aWNsZUNvdW50OiBpc0xvd1BlcmZvcm1hbmNlID8gMzAgOiA2MCxcclxuLy8gICAgIGdyaWRTaXplOiBpc0xvd1BlcmZvcm1hbmNlID8gNDAgOiAzMCxcclxuLy8gICAgIHBhcnRpY2xlU2l6ZTogaXNMb3dQZXJmb3JtYW5jZSA/IHsgbWluOiAxLCBtYXg6IDIgfSA6IHsgbWluOiAxLCBtYXg6IDMgfSxcclxuLy8gICAgIGNvbm5lY3Rpb25EaXN0YW5jZTogaXNMb3dQZXJmb3JtYW5jZSA/IDE1MCA6IDIwMCxcclxuLy8gICAgIGNvbm5lY3Rpb25NYXhDb3VudDogaXNMb3dQZXJmb3JtYW5jZSA/IDIgOiAzLFxyXG4vLyAgICAgZmFkZU9wYWNpdHk6IGlzTG93UGVyZm9ybWFuY2UgPyAwLjIgOiAwLjEsXHJcbi8vICAgICBtYXhGUFM6IGlzTG93UGVyZm9ybWFuY2UgPyAzMCA6IDYwLFxyXG4vLyAgICAgcGFydGljbGVTcGVlZDogaXNMb3dQZXJmb3JtYW5jZSA/IDAuMyA6IDAuNSxcclxuLy8gICAgIG1vdXNlSW5mbHVlbmNlUmFkaXVzOiAxNTAsXHJcbi8vICAgICBtb3VzZUluZmx1ZW5jZVN0cmVuZ3RoOiAwLjUsXHJcbi8vICAgfVxyXG5cclxuLy8gICBjb25zdCBpbml0UGFydGljbGVzID0gdXNlQ2FsbGJhY2soXHJcbi8vICAgICAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4vLyAgICAgICBwYXJ0aWNsZXNSZWYuY3VycmVudCA9IFtdXHJcbi8vICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLnBhcnRpY2xlQ291bnQ7IGkrKykge1xyXG4vLyAgICAgICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4vLyAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIGNhbnZhcy53aWR0aCxcclxuLy8gICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0LFxyXG4vLyAgICAgICAgICAgc2l6ZTogTWF0aC5yYW5kb20oKSAqIChjb25maWcucGFydGljbGVTaXplLm1heCAtIGNvbmZpZy5wYXJ0aWNsZVNpemUubWluKSArIGNvbmZpZy5wYXJ0aWNsZVNpemUubWluLFxyXG4vLyAgICAgICAgICAgc3BlZWRYOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBjb25maWcucGFydGljbGVTcGVlZCxcclxuLy8gICAgICAgICAgIHNwZWVkWTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogY29uZmlnLnBhcnRpY2xlU3BlZWQsXHJcbi8vICAgICAgICAgICBvcGFjaXR5OiBNYXRoLnJhbmRvbSgpICogMC41ICsgMC4yLFxyXG4vLyAgICAgICAgICAgY29ubmVjdGlvbjogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29uZmlnLmNvbm5lY3Rpb25NYXhDb3VudCksXHJcbi8vICAgICAgICAgfSlcclxuLy8gICAgICAgfVxyXG4vLyAgICAgICBjb25uZWN0aW9uc1JlZi5jdXJyZW50ID0gW11cclxuLy8gICAgIH0sXHJcbi8vICAgICBbY29uZmlnLmNvbm5lY3Rpb25NYXhDb3VudF0sXHJcbi8vICAgKVxyXG5cclxuLy8gICBjb25zdCBkcmF3R3JpZCA9IHVzZUNhbGxiYWNrKFxyXG4vLyAgICAgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4vLyAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwgMjU1LCAwLCAwLjEpXCJcclxuLy8gICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNVxyXG5cclxuLy8gICAgICAgLy8gRHJhdyB2ZXJ0aWNhbCBsaW5lc1xyXG4vLyAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSB3aWR0aDsgeCArPSBjb25maWcuZ3JpZFNpemUpIHtcclxuLy8gICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuLy8gICAgICAgICBjdHgubW92ZVRvKHgsIDApXHJcbi8vICAgICAgICAgY3R4LmxpbmVUbyh4LCBoZWlnaHQpXHJcbi8vICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbi8vICAgICAgIH1cclxuXHJcbi8vICAgICAgIC8vIERyYXcgaG9yaXpvbnRhbCBsaW5lc1xyXG4vLyAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBoZWlnaHQ7IHkgKz0gY29uZmlnLmdyaWRTaXplKSB7XHJcbi8vICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbi8vICAgICAgICAgY3R4Lm1vdmVUbygwLCB5KVxyXG4vLyAgICAgICAgIGN0eC5saW5lVG8od2lkdGgsIHkpXHJcbi8vICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbi8vICAgICAgIH1cclxuLy8gICAgIH0sXHJcbi8vICAgICBbY29uZmlnLmdyaWRTaXplXSxcclxuLy8gICApXHJcblxyXG4vLyAgIGNvbnN0IHVwZGF0ZUNvbm5lY3Rpb25zID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4vLyAgICAgY29uc3QgcGFydGljbGVzID0gcGFydGljbGVzUmVmLmN1cnJlbnRcclxuLy8gICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbnNSZWYuY3VycmVudFxyXG5cclxuLy8gICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjb25uZWN0aW9uc1xyXG4vLyAgICAgZm9yIChsZXQgaSA9IGNvbm5lY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbi8vICAgICAgIGNvbm5lY3Rpb25zW2ldLmxpZmUtLVxyXG4vLyAgICAgICBpZiAoY29ubmVjdGlvbnNbaV0ubGlmZSA8PSAwKSB7XHJcbi8vICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGksIDEpXHJcbi8vICAgICAgIH1cclxuLy8gICAgIH1cclxuXHJcbi8vICAgICAvLyBDcmVhdGUgbmV3IGNvbm5lY3Rpb25zXHJcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlcy5sZW5ndGg7IGkrKykge1xyXG4vLyAgICAgICBjb25zdCBwMSA9IHBhcnRpY2xlc1tpXVxyXG5cclxuLy8gICAgICAgLy8gQ291bnQgY3VycmVudCBjb25uZWN0aW9ucyBmb3IgdGhpcyBwYXJ0aWNsZVxyXG4vLyAgICAgICBjb25zdCBjdXJyZW50Q29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucy5maWx0ZXIoKGMpID0+IGMuZnJvbSA9PT0gaSB8fCBjLnRvID09PSBpKS5sZW5ndGhcclxuXHJcbi8vICAgICAgIGlmIChjdXJyZW50Q29ubmVjdGlvbnMgPCBwMS5jb25uZWN0aW9uKSB7XHJcbi8vICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcGFydGljbGVzLmxlbmd0aDsgaisrKSB7XHJcbi8vICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRpY2xlc1tqXVxyXG4vLyAgICAgICAgICAgY29uc3QgZHggPSBwMS54IC0gcDIueFxyXG4vLyAgICAgICAgICAgY29uc3QgZHkgPSBwMS55IC0gcDIueVxyXG4vLyAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXHJcblxyXG4vLyAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY29uZmlnLmNvbm5lY3Rpb25EaXN0YW5jZSkge1xyXG4vLyAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBleGlzdHNcclxuLy8gICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkV4aXN0cyA9IGNvbm5lY3Rpb25zLnNvbWUoXHJcbi8vICAgICAgICAgICAgICAgKGMpID0+IChjLmZyb20gPT09IGkgJiYgYy50byA9PT0gaikgfHwgKGMuZnJvbSA9PT0gaiAmJiBjLnRvID09PSBpKSxcclxuLy8gICAgICAgICAgICAgKVxyXG5cclxuLy8gICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uRXhpc3RzKSB7XHJcbi8vICAgICAgICAgICAgICAgY29uc3QgbWF4TGlmZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwMCkgKyAxMDBcclxuLy8gICAgICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHtcclxuLy8gICAgICAgICAgICAgICAgIGZyb206IGksXHJcbi8vICAgICAgICAgICAgICAgICB0bzogaixcclxuLy8gICAgICAgICAgICAgICAgIGxpZmU6IG1heExpZmUsXHJcbi8vICAgICAgICAgICAgICAgICBtYXhMaWZlOiBtYXhMaWZlLFxyXG4vLyAgICAgICAgICAgICAgIH0pXHJcbi8vICAgICAgICAgICAgICAgYnJlYWtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtjb25maWcuY29ubmVjdGlvbkRpc3RhbmNlXSlcclxuXHJcbi8vICAgY29uc3QgYW5pbWF0ZSA9IHVzZUNhbGxiYWNrKFxyXG4vLyAgICAgKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB7XHJcbi8vICAgICAgIGxldCBsYXN0VGltZSA9IDBcclxuLy8gICAgICAgY29uc3QgdGFyZ2V0RnJhbWVUaW1lID0gMTAwMCAvIGNvbmZpZy5tYXhGUFNcclxuXHJcbi8vICAgICAgIGNvbnN0IGZyYW1lID0gKGN1cnJlbnRUaW1lOiBudW1iZXIpID0+IHtcclxuLy8gICAgICAgICBpZiAoY3VycmVudFRpbWUgLSBsYXN0VGltZSA8IHRhcmdldEZyYW1lVGltZSkge1xyXG4vLyAgICAgICAgICAgYW5pbWF0aW9uSWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSlcclxuLy8gICAgICAgICAgIHJldHVyblxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lXHJcblxyXG4vLyAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIGZhZGUgZWZmZWN0XHJcbi8vICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGByZ2JhKDAsIDAsIDAsICR7Y29uZmlnLmZhZGVPcGFjaXR5fSlgXHJcbi8vICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcclxuXHJcbi8vICAgICAgICAgLy8gRHJhdyBncmlkXHJcbi8vICAgICAgICAgZHJhd0dyaWQoY3R4LCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXHJcblxyXG4vLyAgICAgICAgIC8vIFVwZGF0ZSBhbmQgZHJhdyBjb25uZWN0aW9uc1xyXG4vLyAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25zKClcclxuXHJcbi8vICAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBjb25uZWN0aW9uc1JlZi5jdXJyZW50XHJcbi8vICAgICAgICAgY29uc3QgcGFydGljbGVzID0gcGFydGljbGVzUmVmLmN1cnJlbnRcclxuXHJcbi8vICAgICAgICAgLy8gRHJhdyBjb25uZWN0aW9uc1xyXG4vLyAgICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBjb25uZWN0aW9ucykge1xyXG4vLyAgICAgICAgICAgY29uc3QgcDEgPSBwYXJ0aWNsZXNbY29ubmVjdGlvbi5mcm9tXVxyXG4vLyAgICAgICAgICAgY29uc3QgcDIgPSBwYXJ0aWNsZXNbY29ubmVjdGlvbi50b11cclxuXHJcbi8vICAgICAgICAgICBjb25zdCBhbHBoYSA9IChjb25uZWN0aW9uLmxpZmUgLyBjb25uZWN0aW9uLm1heExpZmUpICogMC44XHJcbi8vICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSgwLCAyNTUsIDAsICR7YWxwaGF9KWBcclxuLy8gICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxXHJcblxyXG4vLyAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbi8vICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpXHJcbi8vICAgICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpXHJcbi8vICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuXHJcbi8vICAgICAgICAgICAvLyBEcmF3IGRhdGEgcGFja2V0IG1vdmluZyBhbG9uZyB0aGUgY29ubmVjdGlvblxyXG4vLyAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSAxIC0gY29ubmVjdGlvbi5saWZlIC8gY29ubmVjdGlvbi5tYXhMaWZlXHJcbi8vICAgICAgICAgICBjb25zdCBwYWNrZXRYID0gcDEueCArIChwMi54IC0gcDEueCkgKiBwcm9ncmVzc1xyXG4vLyAgICAgICAgICAgY29uc3QgcGFja2V0WSA9IHAxLnkgKyAocDIueSAtIHAxLnkpICogcHJvZ3Jlc3NcclxuXHJcbi8vICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoMCwgMjU1LCAyNTUsICR7YWxwaGEgKiAyfSlgXHJcbi8vICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuLy8gICAgICAgICAgIGN0eC5hcmMocGFja2V0WCwgcGFja2V0WSwgMiwgMCwgTWF0aC5QSSAqIDIpXHJcbi8vICAgICAgICAgICBjdHguZmlsbCgpXHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAvLyBVcGRhdGUgYW5kIGRyYXcgcGFydGljbGVzXHJcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcclxuLy8gICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0aWNsZXNbaV1cclxuXHJcbi8vICAgICAgICAgICAvLyBBcHBseSBtb3VzZSBpbmZsdWVuY2UgaWYgYWN0aXZlXHJcbi8vICAgICAgICAgICBpZiAobW91c2VSZWYuY3VycmVudC5hY3RpdmUpIHtcclxuLy8gICAgICAgICAgICAgY29uc3QgZHggPSBtb3VzZVJlZi5jdXJyZW50LnggLSBwLnhcclxuLy8gICAgICAgICAgICAgY29uc3QgZHkgPSBtb3VzZVJlZi5jdXJyZW50LnkgLSBwLnlcclxuLy8gICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXHJcblxyXG4vLyAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBjb25maWcubW91c2VJbmZsdWVuY2VSYWRpdXMpIHtcclxuLy8gICAgICAgICAgICAgICBjb25zdCBmb3JjZSA9IChjb25maWcubW91c2VJbmZsdWVuY2VSYWRpdXMgLSBkaXN0YW5jZSkgLyBjb25maWcubW91c2VJbmZsdWVuY2VSYWRpdXNcclxuLy8gICAgICAgICAgICAgICBwLnNwZWVkWCArPSBkeCAqIGZvcmNlICogY29uZmlnLm1vdXNlSW5mbHVlbmNlU3RyZW5ndGggKiAwLjAxXHJcbi8vICAgICAgICAgICAgICAgcC5zcGVlZFkgKz0gZHkgKiBmb3JjZSAqIGNvbmZpZy5tb3VzZUluZmx1ZW5jZVN0cmVuZ3RoICogMC4wMVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgICAgLy8gQXBwbHkgc3BlZWQgbGltaXRzXHJcbi8vICAgICAgICAgICBjb25zdCBtYXhTcGVlZCA9IDJcclxuLy8gICAgICAgICAgIGNvbnN0IHNwZWVkID0gTWF0aC5zcXJ0KHAuc3BlZWRYICogcC5zcGVlZFggKyBwLnNwZWVkWSAqIHAuc3BlZWRZKVxyXG4vLyAgICAgICAgICAgaWYgKHNwZWVkID4gbWF4U3BlZWQpIHtcclxuLy8gICAgICAgICAgICAgcC5zcGVlZFggPSAocC5zcGVlZFggLyBzcGVlZCkgKiBtYXhTcGVlZFxyXG4vLyAgICAgICAgICAgICBwLnNwZWVkWSA9IChwLnNwZWVkWSAvIHNwZWVkKSAqIG1heFNwZWVkXHJcbi8vICAgICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uXHJcbi8vICAgICAgICAgICBwLnggKz0gcC5zcGVlZFhcclxuLy8gICAgICAgICAgIHAueSArPSBwLnNwZWVkWVxyXG5cclxuLy8gICAgICAgICAgIC8vIEJvdW5kYXJ5IGNoZWNrIHdpdGggYm91bmNlXHJcbi8vICAgICAgICAgICBpZiAocC54IDwgMCkge1xyXG4vLyAgICAgICAgICAgICBwLnggPSAwXHJcbi8vICAgICAgICAgICAgIHAuc3BlZWRYICo9IC0xXHJcbi8vICAgICAgICAgICB9IGVsc2UgaWYgKHAueCA+IGNhbnZhcy53aWR0aCkge1xyXG4vLyAgICAgICAgICAgICBwLnggPSBjYW52YXMud2lkdGhcclxuLy8gICAgICAgICAgICAgcC5zcGVlZFggKj0gLTFcclxuLy8gICAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgICBpZiAocC55IDwgMCkge1xyXG4vLyAgICAgICAgICAgICBwLnkgPSAwXHJcbi8vICAgICAgICAgICAgIHAuc3BlZWRZICo9IC0xXHJcbi8vICAgICAgICAgICB9IGVsc2UgaWYgKHAueSA+IGNhbnZhcy5oZWlnaHQpIHtcclxuLy8gICAgICAgICAgICAgcC55ID0gY2FudmFzLmhlaWdodFxyXG4vLyAgICAgICAgICAgICBwLnNwZWVkWSAqPSAtMVxyXG4vLyAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgIC8vIEFwcGx5IGZyaWN0aW9uXHJcbi8vICAgICAgICAgICBwLnNwZWVkWCAqPSAwLjk5XHJcbi8vICAgICAgICAgICBwLnNwZWVkWSAqPSAwLjk5XHJcblxyXG4vLyAgICAgICAgICAgLy8gRHJhdyBwYXJ0aWNsZVxyXG4vLyAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHAuc2l6ZVxyXG4vLyAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQocC54LCBwLnksIDAsIHAueCwgcC55LCBzaXplICogMilcclxuLy8gICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgwLCAyNTUsIDAsICR7cC5vcGFjaXR5fSlgKVxyXG4vLyAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgwLCAyNTUsIDAsIDApXCIpXHJcblxyXG4vLyAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50XHJcbi8vICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuLy8gICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIHNpemUgKiAyLCAwLCBNYXRoLlBJICogMilcclxuLy8gICAgICAgICAgIGN0eC5maWxsKClcclxuXHJcbi8vICAgICAgICAgICAvLyBDb3JlIG9mIHRoZSBwYXJ0aWNsZVxyXG4vLyAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGByZ2JhKDAsIDI1NSwgMCwgJHtwLm9wYWNpdHkgKiAyfSlgXHJcbi8vICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuLy8gICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIHNpemUsIDAsIE1hdGguUEkgKiAyKVxyXG4vLyAgICAgICAgICAgY3R4LmZpbGwoKVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgYW5pbWF0aW9uSWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSlcclxuLy8gICAgICAgfVxyXG5cclxuLy8gICAgICAgYW5pbWF0aW9uSWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSlcclxuLy8gICAgIH0sXHJcbi8vICAgICBbY29uZmlnLCBkcmF3R3JpZCwgdXBkYXRlQ29ubmVjdGlvbnNdLFxyXG4vLyAgIClcclxuXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XHJcbi8vICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXHJcblxyXG4vLyAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxyXG4vLyAgICAgaWYgKCFjdHgpIHJldHVyblxyXG5cclxuLy8gICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byB3aW5kb3cgc2l6ZVxyXG4vLyAgICAgY29uc3QgcmVzaXplQ2FudmFzID0gKCkgPT4ge1xyXG4vLyAgICAgICBjb25zdCBkcHIgPSBpc0xvd1BlcmZvcm1hbmNlID8gMSA6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcclxuLy8gICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG5cclxuLy8gICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIGRwclxyXG4vLyAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiBkcHJcclxuLy8gICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gcmVjdC53aWR0aCArIFwicHhcIlxyXG4vLyAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyBcInB4XCJcclxuXHJcbi8vICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcilcclxuLy8gICAgICAgaW5pdFBhcnRpY2xlcyhjYW52YXMpXHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgLy8gTW91c2UgaW50ZXJhY3Rpb25cclxuLy8gICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbi8vICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuLy8gICAgICAgbW91c2VSZWYuY3VycmVudCA9IHtcclxuLy8gICAgICAgICB4OiBlLmNsaWVudFggLSByZWN0LmxlZnQsXHJcbi8vICAgICAgICAgeTogZS5jbGllbnRZIC0gcmVjdC50b3AsXHJcbi8vICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4vLyAgICAgICB9XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcclxuLy8gICAgICAgbW91c2VSZWYuY3VycmVudC5hY3RpdmUgPSBmYWxzZVxyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSlcclxuLy8gICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVNb3VzZUxlYXZlKVxyXG4vLyAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcclxuLy8gICAgICAgbW91c2VSZWYuY3VycmVudC5hY3RpdmUgPSB0cnVlXHJcbi8vICAgICB9KVxyXG5cclxuLy8gICAgIC8vIFRvdWNoIGludGVyYWN0aW9uIGZvciBtb2JpbGVcclxuLy8gICAgIGNvbnN0IGhhbmRsZVRvdWNoTW92ZSA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XHJcbi8vICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG4vLyAgICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuLy8gICAgICAgICBtb3VzZVJlZi5jdXJyZW50ID0ge1xyXG4vLyAgICAgICAgICAgeDogZS50b3VjaGVzWzBdLmNsaWVudFggLSByZWN0LmxlZnQsXHJcbi8vICAgICAgICAgICB5OiBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHJlY3QudG9wLFxyXG4vLyAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIGNvbnN0IGhhbmRsZVRvdWNoRW5kID0gKCkgPT4ge1xyXG4vLyAgICAgICBtb3VzZVJlZi5jdXJyZW50LmFjdGl2ZSA9IGZhbHNlXHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgaGFuZGxlVG91Y2hNb3ZlKVxyXG4vLyAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoYW5kbGVUb3VjaEVuZClcclxuXHJcbi8vICAgICByZXNpemVDYW52YXMoKVxyXG4vLyAgICAgYW5pbWF0ZShjYW52YXMsIGN0eClcclxuXHJcbi8vICAgICAvLyBUaHJvdHRsZWQgcmVzaXplIGhhbmRsZXJcclxuLy8gICAgIGxldCByZXNpemVUaW1lb3V0OiBOb2RlSlMuVGltZW91dFxyXG4vLyAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4vLyAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dClcclxuLy8gICAgICAgcmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQocmVzaXplQ2FudmFzLCAyNTApXHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKVxyXG5cclxuLy8gICAgIHJldHVybiAoKSA9PiB7XHJcbi8vICAgICAgIGlmIChhbmltYXRpb25JZFJlZi5jdXJyZW50KSB7XHJcbi8vICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWRSZWYuY3VycmVudClcclxuLy8gICAgICAgfVxyXG4vLyAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dClcclxuLy8gICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKVxyXG4vLyAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpXHJcbi8vICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVNb3VzZUxlYXZlKVxyXG4vLyAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBoYW5kbGVUb3VjaE1vdmUpXHJcbi8vICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgaGFuZGxlVG91Y2hFbmQpXHJcbi8vICAgICB9XHJcbi8vICAgfSwgW2FuaW1hdGUsIGluaXRQYXJ0aWNsZXMsIGlzTG93UGVyZm9ybWFuY2VdKVxyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGNhbnZhc1xyXG4vLyAgICAgICByZWY9e2NhbnZhc1JlZn1cclxuLy8gICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCB6LTAgdy1mdWxsIGgtZnVsbFwiXHJcbi8vICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgd2lkdGg6IFwiMTAwdndcIixcclxuLy8gICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcclxuLy8gICAgICAgICB3aWxsQ2hhbmdlOiBcInRyYW5zZm9ybVwiLFxyXG4vLyAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLCAvLyBFbmFibGUgbW91c2UgaW50ZXJhY3Rpb25cclxuLy8gICAgICAgfX1cclxuLy8gICAgIC8+XHJcbi8vICAgKVxyXG4vLyB9XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/cyber-grid.tsx\n"));

/***/ })

});