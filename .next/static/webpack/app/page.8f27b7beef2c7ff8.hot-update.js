"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/background-animations.tsx":
/*!**************************************************!*\
  !*** ./src/components/background-animations.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BackgroundAnimations)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _cyber_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cyber-grid */ \"(app-pages-browser)/./src/components/cyber-grid.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction BackgroundAnimations() {\n    _s();\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isLowPerformance, setIsLowPerformance] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    // Performance detection and optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"BackgroundAnimations.useEffect\": ()=>{\n            setMounted(true);\n            // Detect low performance devices\n            const checkPerformance = {\n                \"BackgroundAnimations.useEffect.checkPerformance\": ()=>{\n                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n                    const isLowMemory = navigator.deviceMemory && navigator.deviceMemory < 4;\n                    const isSlowConnection = navigator.connection && navigator.connection.effectiveType === \"slow-2g\";\n                    setIsLowPerformance(isMobile || isLowMemory || isSlowConnection);\n                }\n            }[\"BackgroundAnimations.useEffect.checkPerformance\"];\n            checkPerformance();\n        }\n    }[\"BackgroundAnimations.useEffect\"], []);\n    if (!mounted) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 z-0 overflow-hidden pointer-events-none\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_cyber_grid__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            isLowPerformance: isLowPerformance\n        }, void 0, false, {\n            fileName: \"D:\\\\portfolio\\\\src\\\\components\\\\background-animations.tsx\",\n            lineNumber: 31,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\portfolio\\\\src\\\\components\\\\background-animations.tsx\",\n        lineNumber: 30,\n        columnNumber: 5\n    }, this);\n}\n_s(BackgroundAnimations, \"2n8FmAaO3gXdl54jKtJ7hRMKLGw=\");\n_c = BackgroundAnimations;\nvar _c;\n$RefreshReg$(_c, \"BackgroundAnimations\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2JhY2tncm91bmQtYW5pbWF0aW9ucy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVvQztBQUNPO0FBRTVCLFNBQVNHOztJQUN0QixNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR0osK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDSyxrQkFBa0JDLG9CQUFvQixHQUFHTiwrQ0FBUUEsQ0FBQztJQUV6RCx5Q0FBeUM7SUFDekNDLGdEQUFTQTswQ0FBQztZQUNSRyxXQUFXO1lBRVgsaUNBQWlDO1lBQ2pDLE1BQU1HO21FQUFtQjtvQkFDdkIsTUFBTUMsV0FBVyxpRUFBaUVDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztvQkFDMUcsTUFBTUMsY0FBYyxVQUFtQkMsWUFBWSxJQUFJLFVBQW1CQSxZQUFZLEdBQUc7b0JBQ3pGLE1BQU1DLG1CQUNKLFVBQW1CQyxVQUFVLElBQUksVUFBbUJBLFVBQVUsQ0FBQ0MsYUFBYSxLQUFLO29CQUVuRlYsb0JBQW9CRSxZQUFZSSxlQUFlRTtnQkFDakQ7O1lBRUFQO1FBQ0Y7eUNBQUcsRUFBRTtJQUVMLElBQUksQ0FBQ0osU0FBUyxPQUFPO0lBRXJCLHFCQUNFLDhEQUFDYztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDbkIsbURBQVNBO1lBQUNNLGtCQUFrQkE7Ozs7Ozs7Ozs7O0FBR25DO0dBNUJ3Qkg7S0FBQUEiLCJzb3VyY2VzIjpbIkQ6XFxwb3J0Zm9saW9cXHNyY1xcY29tcG9uZW50c1xcYmFja2dyb3VuZC1hbmltYXRpb25zLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5cclxuaW1wb3J0IEN5YmVyR3JpZCBmcm9tIFwiLi9jeWJlci1ncmlkXCJcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYWNrZ3JvdW5kQW5pbWF0aW9ucygpIHtcclxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbaXNMb3dQZXJmb3JtYW5jZSwgc2V0SXNMb3dQZXJmb3JtYW5jZV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuXHJcbiAgLy8gUGVyZm9ybWFuY2UgZGV0ZWN0aW9uIGFuZCBvcHRpbWl6YXRpb25cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgc2V0TW91bnRlZCh0cnVlKVxyXG5cclxuICAgIC8vIERldGVjdCBsb3cgcGVyZm9ybWFuY2UgZGV2aWNlc1xyXG4gICAgY29uc3QgY2hlY2tQZXJmb3JtYW5jZSA9ICgpID0+IHtcclxuICAgICAgY29uc3QgaXNNb2JpbGUgPSAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcclxuICAgICAgY29uc3QgaXNMb3dNZW1vcnkgPSAobmF2aWdhdG9yIGFzIGFueSkuZGV2aWNlTWVtb3J5ICYmIChuYXZpZ2F0b3IgYXMgYW55KS5kZXZpY2VNZW1vcnkgPCA0XHJcbiAgICAgIGNvbnN0IGlzU2xvd0Nvbm5lY3Rpb24gPVxyXG4gICAgICAgIChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uICYmIChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUgPT09IFwic2xvdy0yZ1wiXHJcblxyXG4gICAgICBzZXRJc0xvd1BlcmZvcm1hbmNlKGlzTW9iaWxlIHx8IGlzTG93TWVtb3J5IHx8IGlzU2xvd0Nvbm5lY3Rpb24pXHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tQZXJmb3JtYW5jZSgpXHJcbiAgfSwgW10pXHJcblxyXG4gIGlmICghbW91bnRlZCkgcmV0dXJuIG51bGxcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCB6LTAgb3ZlcmZsb3ctaGlkZGVuIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cclxuICAgICAgPEN5YmVyR3JpZCBpc0xvd1BlcmZvcm1hbmNlPXtpc0xvd1BlcmZvcm1hbmNlfSAvPlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XHJcbiJdLCJuYW1lcyI6WyJDeWJlckdyaWQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkJhY2tncm91bmRBbmltYXRpb25zIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJpc0xvd1BlcmZvcm1hbmNlIiwic2V0SXNMb3dQZXJmb3JtYW5jZSIsImNoZWNrUGVyZm9ybWFuY2UiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0xvd01lbW9yeSIsImRldmljZU1lbW9yeSIsImlzU2xvd0Nvbm5lY3Rpb24iLCJjb25uZWN0aW9uIiwiZWZmZWN0aXZlVHlwZSIsImRpdiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/background-animations.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/cyber-grid.tsx":
/*!***************************************!*\
  !*** ./src/components/cyber-grid.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CyberGrid)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction CyberGrid(param) {\n    let { isLowPerformance = false } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const particlesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const connectionsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const mouseRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0,\n        active: false\n    });\n    // Performance-based configuration\n    const config = {\n        particleCount: isLowPerformance ? 30 : 60,\n        gridSize: isLowPerformance ? 40 : 30,\n        particleSize: isLowPerformance ? {\n            min: 1,\n            max: 2\n        } : {\n            min: 1,\n            max: 3\n        },\n        connectionDistance: isLowPerformance ? 150 : 200,\n        connectionMaxCount: isLowPerformance ? 2 : 3,\n        fadeOpacity: isLowPerformance ? 0.2 : 0.1,\n        maxFPS: isLowPerformance ? 30 : 60,\n        particleSpeed: isLowPerformance ? 0.3 : 0.5,\n        mouseInfluenceRadius: 150,\n        mouseInfluenceStrength: 0.5\n    };\n    const initParticles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CyberGrid.useCallback[initParticles]\": (canvas)=>{\n            particlesRef.current = [];\n            for(let i = 0; i < config.particleCount; i++){\n                particlesRef.current.push({\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height,\n                    size: Math.random() * (config.particleSize.max - config.particleSize.min) + config.particleSize.min,\n                    speedX: (Math.random() - 0.5) * config.particleSpeed,\n                    speedY: (Math.random() - 0.5) * config.particleSpeed,\n                    opacity: Math.random() * 0.5 + 0.2,\n                    connection: Math.floor(Math.random() * config.connectionMaxCount)\n                });\n            }\n            connectionsRef.current = [];\n        }\n    }[\"CyberGrid.useCallback[initParticles]\"], [\n        config.connectionMaxCount\n    ]);\n    const drawGrid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CyberGrid.useCallback[drawGrid]\": (ctx, width, height)=>{\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.1)\";\n            ctx.lineWidth = 0.5;\n            // Draw vertical lines\n            for(let x = 0; x <= width; x += config.gridSize){\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, height);\n                ctx.stroke();\n            }\n            // Draw horizontal lines\n            for(let y = 0; y <= height; y += config.gridSize){\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(width, y);\n                ctx.stroke();\n            }\n        }\n    }[\"CyberGrid.useCallback[drawGrid]\"], [\n        config.gridSize\n    ]);\n    const updateConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CyberGrid.useCallback[updateConnections]\": ()=>{\n            const particles = particlesRef.current;\n            const connections = connectionsRef.current;\n            // Update existing connections\n            for(let i = connections.length - 1; i >= 0; i--){\n                connections[i].life--;\n                if (connections[i].life <= 0) {\n                    connections.splice(i, 1);\n                }\n            }\n            // Create new connections\n            for(let i = 0; i < particles.length; i++){\n                const p1 = particles[i];\n                // Count current connections for this particle\n                const currentConnections = connections.filter({\n                    \"CyberGrid.useCallback[updateConnections]\": (c)=>c.from === i || c.to === i\n                }[\"CyberGrid.useCallback[updateConnections]\"]).length;\n                if (currentConnections < p1.connection) {\n                    for(let j = i + 1; j < particles.length; j++){\n                        const p2 = particles[j];\n                        const dx = p1.x - p2.x;\n                        const dy = p1.y - p2.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        if (distance < config.connectionDistance) {\n                            // Check if this connection already exists\n                            const connectionExists = connections.some({\n                                \"CyberGrid.useCallback[updateConnections].connectionExists\": (c)=>c.from === i && c.to === j || c.from === j && c.to === i\n                            }[\"CyberGrid.useCallback[updateConnections].connectionExists\"]);\n                            if (!connectionExists) {\n                                const maxLife = Math.floor(Math.random() * 200) + 100;\n                                connections.push({\n                                    from: i,\n                                    to: j,\n                                    life: maxLife,\n                                    maxLife: maxLife\n                                });\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }[\"CyberGrid.useCallback[updateConnections]\"], [\n        config.connectionDistance\n    ]);\n    const animate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CyberGrid.useCallback[animate]\": (canvas, ctx)=>{\n            let lastTime = 0;\n            const targetFrameTime = 1000 / config.maxFPS;\n            const frame = {\n                \"CyberGrid.useCallback[animate].frame\": (currentTime)=>{\n                    if (currentTime - lastTime < targetFrameTime) {\n                        animationIdRef.current = requestAnimationFrame(frame);\n                        return;\n                    }\n                    lastTime = currentTime;\n                    // Clear canvas with fade effect\n                    ctx.fillStyle = \"rgba(0, 0, 0, \".concat(config.fadeOpacity, \")\");\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Draw grid\n                    drawGrid(ctx, canvas.width, canvas.height);\n                    // Update and draw connections\n                    updateConnections();\n                    const connections = connectionsRef.current;\n                    const particles = particlesRef.current;\n                    // Draw connections\n                    for (const connection of connections){\n                        const p1 = particles[connection.from];\n                        const p2 = particles[connection.to];\n                        const alpha = connection.life / connection.maxLife * 0.8;\n                        ctx.strokeStyle = \"rgba(0, 255, 0, \".concat(alpha, \")\");\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(p1.x, p1.y);\n                        ctx.lineTo(p2.x, p2.y);\n                        ctx.stroke();\n                        // Draw data packet moving along the connection\n                        const progress = 1 - connection.life / connection.maxLife;\n                        const packetX = p1.x + (p2.x - p1.x) * progress;\n                        const packetY = p1.y + (p2.y - p1.y) * progress;\n                        ctx.fillStyle = \"rgba(0, 255, 255, \".concat(alpha * 2, \")\");\n                        ctx.beginPath();\n                        ctx.arc(packetX, packetY, 2, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                    // Update and draw particles\n                    for(let i = 0; i < particles.length; i++){\n                        const p = particles[i];\n                        // Apply mouse influence if active\n                        if (mouseRef.current.active) {\n                            const dx = mouseRef.current.x - p.x;\n                            const dy = mouseRef.current.y - p.y;\n                            const distance = Math.sqrt(dx * dx + dy * dy);\n                            if (distance < config.mouseInfluenceRadius) {\n                                const force = (config.mouseInfluenceRadius - distance) / config.mouseInfluenceRadius;\n                                p.speedX += dx * force * config.mouseInfluenceStrength * 0.01;\n                                p.speedY += dy * force * config.mouseInfluenceStrength * 0.01;\n                            }\n                        }\n                        // Apply speed limits\n                        const maxSpeed = 2;\n                        const speed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n                        if (speed > maxSpeed) {\n                            p.speedX = p.speedX / speed * maxSpeed;\n                            p.speedY = p.speedY / speed * maxSpeed;\n                        }\n                        // Update position\n                        p.x += p.speedX;\n                        p.y += p.speedY;\n                        // Boundary check with bounce\n                        if (p.x < 0) {\n                            p.x = 0;\n                            p.speedX *= -1;\n                        } else if (p.x > canvas.width) {\n                            p.x = canvas.width;\n                            p.speedX *= -1;\n                        }\n                        if (p.y < 0) {\n                            p.y = 0;\n                            p.speedY *= -1;\n                        } else if (p.y > canvas.height) {\n                            p.y = canvas.height;\n                            p.speedY *= -1;\n                        }\n                        // Apply friction\n                        p.speedX *= 0.99;\n                        p.speedY *= 0.99;\n                        // Draw particle\n                        const size = p.size;\n                        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);\n                        gradient.addColorStop(0, \"rgba(0, 255, 0, \".concat(p.opacity, \")\"));\n                        gradient.addColorStop(1, \"rgba(0, 255, 0, 0)\");\n                        ctx.fillStyle = gradient;\n                        ctx.beginPath();\n                        ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);\n                        ctx.fill();\n                        // Core of the particle\n                        ctx.fillStyle = \"rgba(0, 255, 0, \".concat(p.opacity * 2, \")\");\n                        ctx.beginPath();\n                        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                    animationIdRef.current = requestAnimationFrame(frame);\n                }\n            }[\"CyberGrid.useCallback[animate].frame\"];\n            animationIdRef.current = requestAnimationFrame(frame);\n        }\n    }[\"CyberGrid.useCallback[animate]\"], [\n        config,\n        drawGrid,\n        updateConnections\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CyberGrid.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) return;\n            // Set canvas dimensions to window size\n            const resizeCanvas = {\n                \"CyberGrid.useEffect.resizeCanvas\": ()=>{\n                    const dpr = isLowPerformance ? 1 : window.devicePixelRatio || 1;\n                    const rect = canvas.getBoundingClientRect();\n                    canvas.width = rect.width * dpr;\n                    canvas.height = rect.height * dpr;\n                    canvas.style.width = rect.width + \"px\";\n                    canvas.style.height = rect.height + \"px\";\n                    ctx.scale(dpr, dpr);\n                    initParticles(canvas);\n                }\n            }[\"CyberGrid.useEffect.resizeCanvas\"];\n            // Mouse interaction\n            const handleMouseMove = {\n                \"CyberGrid.useEffect.handleMouseMove\": (e)=>{\n                    const rect = canvas.getBoundingClientRect();\n                    mouseRef.current = {\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                        active: true\n                    };\n                }\n            }[\"CyberGrid.useEffect.handleMouseMove\"];\n            const handleMouseLeave = {\n                \"CyberGrid.useEffect.handleMouseLeave\": ()=>{\n                    mouseRef.current.active = false;\n                }\n            }[\"CyberGrid.useEffect.handleMouseLeave\"];\n            canvas.addEventListener(\"mousemove\", handleMouseMove);\n            canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n            canvas.addEventListener(\"mouseenter\", {\n                \"CyberGrid.useEffect\": ()=>{\n                    mouseRef.current.active = true;\n                }\n            }[\"CyberGrid.useEffect\"]);\n            // Touch interaction for mobile\n            const handleTouchMove = {\n                \"CyberGrid.useEffect.handleTouchMove\": (e)=>{\n                    if (e.touches.length > 0) {\n                        const rect = canvas.getBoundingClientRect();\n                        mouseRef.current = {\n                            x: e.touches[0].clientX - rect.left,\n                            y: e.touches[0].clientY - rect.top,\n                            active: true\n                        };\n                    }\n                }\n            }[\"CyberGrid.useEffect.handleTouchMove\"];\n            const handleTouchEnd = {\n                \"CyberGrid.useEffect.handleTouchEnd\": ()=>{\n                    mouseRef.current.active = false;\n                }\n            }[\"CyberGrid.useEffect.handleTouchEnd\"];\n            canvas.addEventListener(\"touchmove\", handleTouchMove);\n            canvas.addEventListener(\"touchend\", handleTouchEnd);\n            resizeCanvas();\n            animate(canvas, ctx);\n            // Throttled resize handler\n            let resizeTimeout;\n            const handleResize = {\n                \"CyberGrid.useEffect.handleResize\": ()=>{\n                    clearTimeout(resizeTimeout);\n                    resizeTimeout = setTimeout(resizeCanvas, 250);\n                }\n            }[\"CyberGrid.useEffect.handleResize\"];\n            window.addEventListener(\"resize\", handleResize);\n            return ({\n                \"CyberGrid.useEffect\": ()=>{\n                    if (animationIdRef.current) {\n                        cancelAnimationFrame(animationIdRef.current);\n                    }\n                    clearTimeout(resizeTimeout);\n                    window.removeEventListener(\"resize\", handleResize);\n                    canvas.removeEventListener(\"mousemove\", handleMouseMove);\n                    canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n                    canvas.removeEventListener(\"touchmove\", handleTouchMove);\n                    canvas.removeEventListener(\"touchend\", handleTouchEnd);\n                }\n            })[\"CyberGrid.useEffect\"];\n        }\n    }[\"CyberGrid.useEffect\"], [\n        animate,\n        initParticles,\n        isLowPerformance\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 z-0 w-full h-full\",\n        style: {\n            width: \"100vw\",\n            height: \"100vh\",\n            willChange: \"transform\",\n            pointerEvents: \"auto\"\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\portfolio\\\\src\\\\components\\\\cyber-grid.tsx\",\n        lineNumber: 350,\n        columnNumber: 5\n    }, this);\n}\n_s(CyberGrid, \"zYe9FR8njVk9lDuGjyFaYDVHwBE=\");\n_c = CyberGrid;\nvar _c;\n$RefreshReg$(_c, \"CyberGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2N5YmVyLWdyaWQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVzRDtBQXVCdkMsU0FBU0csVUFBVSxLQUE0QztRQUE1QyxFQUFFQyxtQkFBbUIsS0FBSyxFQUFrQixHQUE1Qzs7SUFDaEMsTUFBTUMsWUFBWUosNkNBQU1BLENBQW9CO0lBQzVDLE1BQU1LLGlCQUFpQkwsNkNBQU1BO0lBQzdCLE1BQU1NLGVBQWVOLDZDQUFNQSxDQUFhLEVBQUU7SUFDMUMsTUFBTU8saUJBQWlCUCw2Q0FBTUEsQ0FBZSxFQUFFO0lBQzlDLE1BQU1RLFdBQVdSLDZDQUFNQSxDQUFDO1FBQUVTLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxRQUFRO0lBQU07SUFFcEQsa0NBQWtDO0lBQ2xDLE1BQU1DLFNBQVM7UUFDYkMsZUFBZVYsbUJBQW1CLEtBQUs7UUFDdkNXLFVBQVVYLG1CQUFtQixLQUFLO1FBQ2xDWSxjQUFjWixtQkFBbUI7WUFBRWEsS0FBSztZQUFHQyxLQUFLO1FBQUUsSUFBSTtZQUFFRCxLQUFLO1lBQUdDLEtBQUs7UUFBRTtRQUN2RUMsb0JBQW9CZixtQkFBbUIsTUFBTTtRQUM3Q2dCLG9CQUFvQmhCLG1CQUFtQixJQUFJO1FBQzNDaUIsYUFBYWpCLG1CQUFtQixNQUFNO1FBQ3RDa0IsUUFBUWxCLG1CQUFtQixLQUFLO1FBQ2hDbUIsZUFBZW5CLG1CQUFtQixNQUFNO1FBQ3hDb0Isc0JBQXNCO1FBQ3RCQyx3QkFBd0I7SUFDMUI7SUFFQSxNQUFNQyxnQkFBZ0J4QixrREFBV0E7Z0RBQy9CLENBQUN5QjtZQUNDcEIsYUFBYXFCLE9BQU8sR0FBRyxFQUFFO1lBQ3pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJaEIsT0FBT0MsYUFBYSxFQUFFZSxJQUFLO2dCQUM3Q3RCLGFBQWFxQixPQUFPLENBQUNFLElBQUksQ0FBQztvQkFDeEJwQixHQUFHcUIsS0FBS0MsTUFBTSxLQUFLTCxPQUFPTSxLQUFLO29CQUMvQnRCLEdBQUdvQixLQUFLQyxNQUFNLEtBQUtMLE9BQU9PLE1BQU07b0JBQ2hDQyxNQUFNSixLQUFLQyxNQUFNLEtBQU1uQixDQUFBQSxPQUFPRyxZQUFZLENBQUNFLEdBQUcsR0FBR0wsT0FBT0csWUFBWSxDQUFDQyxHQUFHLElBQUlKLE9BQU9HLFlBQVksQ0FBQ0MsR0FBRztvQkFDbkdtQixRQUFRLENBQUNMLEtBQUtDLE1BQU0sS0FBSyxHQUFFLElBQUtuQixPQUFPVSxhQUFhO29CQUNwRGMsUUFBUSxDQUFDTixLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLbkIsT0FBT1UsYUFBYTtvQkFDcERlLFNBQVNQLEtBQUtDLE1BQU0sS0FBSyxNQUFNO29CQUMvQk8sWUFBWVIsS0FBS1MsS0FBSyxDQUFDVCxLQUFLQyxNQUFNLEtBQUtuQixPQUFPTyxrQkFBa0I7Z0JBQ2xFO1lBQ0Y7WUFDQVosZUFBZW9CLE9BQU8sR0FBRyxFQUFFO1FBQzdCOytDQUNBO1FBQUNmLE9BQU9PLGtCQUFrQjtLQUFDO0lBRzdCLE1BQU1xQixXQUFXdkMsa0RBQVdBOzJDQUMxQixDQUFDd0MsS0FBK0JULE9BQWVDO1lBQzdDUSxJQUFJQyxXQUFXLEdBQUc7WUFDbEJELElBQUlFLFNBQVMsR0FBRztZQUVoQixzQkFBc0I7WUFDdEIsSUFBSyxJQUFJbEMsSUFBSSxHQUFHQSxLQUFLdUIsT0FBT3ZCLEtBQUtHLE9BQU9FLFFBQVEsQ0FBRTtnQkFDaEQyQixJQUFJRyxTQUFTO2dCQUNiSCxJQUFJSSxNQUFNLENBQUNwQyxHQUFHO2dCQUNkZ0MsSUFBSUssTUFBTSxDQUFDckMsR0FBR3dCO2dCQUNkUSxJQUFJTSxNQUFNO1lBQ1o7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSyxJQUFJckMsSUFBSSxHQUFHQSxLQUFLdUIsUUFBUXZCLEtBQUtFLE9BQU9FLFFBQVEsQ0FBRTtnQkFDakQyQixJQUFJRyxTQUFTO2dCQUNiSCxJQUFJSSxNQUFNLENBQUMsR0FBR25DO2dCQUNkK0IsSUFBSUssTUFBTSxDQUFDZCxPQUFPdEI7Z0JBQ2xCK0IsSUFBSU0sTUFBTTtZQUNaO1FBQ0Y7MENBQ0E7UUFBQ25DLE9BQU9FLFFBQVE7S0FBQztJQUduQixNQUFNa0Msb0JBQW9CL0Msa0RBQVdBO29EQUFDO1lBQ3BDLE1BQU1nRCxZQUFZM0MsYUFBYXFCLE9BQU87WUFDdEMsTUFBTXVCLGNBQWMzQyxlQUFlb0IsT0FBTztZQUUxQyw4QkFBOEI7WUFDOUIsSUFBSyxJQUFJQyxJQUFJc0IsWUFBWUMsTUFBTSxHQUFHLEdBQUd2QixLQUFLLEdBQUdBLElBQUs7Z0JBQ2hEc0IsV0FBVyxDQUFDdEIsRUFBRSxDQUFDd0IsSUFBSTtnQkFDbkIsSUFBSUYsV0FBVyxDQUFDdEIsRUFBRSxDQUFDd0IsSUFBSSxJQUFJLEdBQUc7b0JBQzVCRixZQUFZRyxNQUFNLENBQUN6QixHQUFHO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJcUIsVUFBVUUsTUFBTSxFQUFFdkIsSUFBSztnQkFDekMsTUFBTTBCLEtBQUtMLFNBQVMsQ0FBQ3JCLEVBQUU7Z0JBRXZCLDhDQUE4QztnQkFDOUMsTUFBTTJCLHFCQUFxQkwsWUFBWU0sTUFBTTtnRUFBQyxDQUFDQyxJQUFNQSxFQUFFQyxJQUFJLEtBQUs5QixLQUFLNkIsRUFBRUUsRUFBRSxLQUFLL0I7K0RBQUd1QixNQUFNO2dCQUV2RixJQUFJSSxxQkFBcUJELEdBQUdoQixVQUFVLEVBQUU7b0JBQ3RDLElBQUssSUFBSXNCLElBQUloQyxJQUFJLEdBQUdnQyxJQUFJWCxVQUFVRSxNQUFNLEVBQUVTLElBQUs7d0JBQzdDLE1BQU1DLEtBQUtaLFNBQVMsQ0FBQ1csRUFBRTt3QkFDdkIsTUFBTUUsS0FBS1IsR0FBRzdDLENBQUMsR0FBR29ELEdBQUdwRCxDQUFDO3dCQUN0QixNQUFNc0QsS0FBS1QsR0FBRzVDLENBQUMsR0FBR21ELEdBQUduRCxDQUFDO3dCQUN0QixNQUFNc0QsV0FBV2xDLEtBQUttQyxJQUFJLENBQUNILEtBQUtBLEtBQUtDLEtBQUtBO3dCQUUxQyxJQUFJQyxXQUFXcEQsT0FBT00sa0JBQWtCLEVBQUU7NEJBQ3hDLDBDQUEwQzs0QkFDMUMsTUFBTWdELG1CQUFtQmhCLFlBQVlpQixJQUFJOzZGQUN2QyxDQUFDVixJQUFNLEVBQUdDLElBQUksS0FBSzlCLEtBQUs2QixFQUFFRSxFQUFFLEtBQUtDLEtBQU9ILEVBQUVDLElBQUksS0FBS0UsS0FBS0gsRUFBRUUsRUFBRSxLQUFLL0I7OzRCQUduRSxJQUFJLENBQUNzQyxrQkFBa0I7Z0NBQ3JCLE1BQU1FLFVBQVV0QyxLQUFLUyxLQUFLLENBQUNULEtBQUtDLE1BQU0sS0FBSyxPQUFPO2dDQUNsRG1CLFlBQVlyQixJQUFJLENBQUM7b0NBQ2Y2QixNQUFNOUI7b0NBQ04rQixJQUFJQztvQ0FDSlIsTUFBTWdCO29DQUNOQSxTQUFTQTtnQ0FDWDtnQ0FDQTs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7bURBQUc7UUFBQ3hELE9BQU9NLGtCQUFrQjtLQUFDO0lBRTlCLE1BQU1tRCxVQUFVcEUsa0RBQVdBOzBDQUN6QixDQUFDeUIsUUFBMkJlO1lBQzFCLElBQUk2QixXQUFXO1lBQ2YsTUFBTUMsa0JBQWtCLE9BQU8zRCxPQUFPUyxNQUFNO1lBRTVDLE1BQU1tRDt3REFBUSxDQUFDQztvQkFDYixJQUFJQSxjQUFjSCxXQUFXQyxpQkFBaUI7d0JBQzVDbEUsZUFBZXNCLE9BQU8sR0FBRytDLHNCQUFzQkY7d0JBQy9DO29CQUNGO29CQUNBRixXQUFXRztvQkFFWCxnQ0FBZ0M7b0JBQ2hDaEMsSUFBSWtDLFNBQVMsR0FBRyxpQkFBb0MsT0FBbkIvRCxPQUFPUSxXQUFXLEVBQUM7b0JBQ3BEcUIsSUFBSW1DLFFBQVEsQ0FBQyxHQUFHLEdBQUdsRCxPQUFPTSxLQUFLLEVBQUVOLE9BQU9PLE1BQU07b0JBRTlDLFlBQVk7b0JBQ1pPLFNBQVNDLEtBQUtmLE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTTtvQkFFekMsOEJBQThCO29CQUM5QmU7b0JBRUEsTUFBTUUsY0FBYzNDLGVBQWVvQixPQUFPO29CQUMxQyxNQUFNc0IsWUFBWTNDLGFBQWFxQixPQUFPO29CQUV0QyxtQkFBbUI7b0JBQ25CLEtBQUssTUFBTVcsY0FBY1ksWUFBYTt3QkFDcEMsTUFBTUksS0FBS0wsU0FBUyxDQUFDWCxXQUFXb0IsSUFBSSxDQUFDO3dCQUNyQyxNQUFNRyxLQUFLWixTQUFTLENBQUNYLFdBQVdxQixFQUFFLENBQUM7d0JBRW5DLE1BQU1rQixRQUFRLFdBQVl6QixJQUFJLEdBQUdkLFdBQVc4QixPQUFPLEdBQUk7d0JBQ3ZEM0IsSUFBSUMsV0FBVyxHQUFHLG1CQUF5QixPQUFObUMsT0FBTTt3QkFDM0NwQyxJQUFJRSxTQUFTLEdBQUc7d0JBRWhCRixJQUFJRyxTQUFTO3dCQUNiSCxJQUFJSSxNQUFNLENBQUNTLEdBQUc3QyxDQUFDLEVBQUU2QyxHQUFHNUMsQ0FBQzt3QkFDckIrQixJQUFJSyxNQUFNLENBQUNlLEdBQUdwRCxDQUFDLEVBQUVvRCxHQUFHbkQsQ0FBQzt3QkFDckIrQixJQUFJTSxNQUFNO3dCQUVWLCtDQUErQzt3QkFDL0MsTUFBTStCLFdBQVcsSUFBSXhDLFdBQVdjLElBQUksR0FBR2QsV0FBVzhCLE9BQU87d0JBQ3pELE1BQU1XLFVBQVV6QixHQUFHN0MsQ0FBQyxHQUFHLENBQUNvRCxHQUFHcEQsQ0FBQyxHQUFHNkMsR0FBRzdDLENBQUMsSUFBSXFFO3dCQUN2QyxNQUFNRSxVQUFVMUIsR0FBRzVDLENBQUMsR0FBRyxDQUFDbUQsR0FBR25ELENBQUMsR0FBRzRDLEdBQUc1QyxDQUFDLElBQUlvRTt3QkFFdkNyQyxJQUFJa0MsU0FBUyxHQUFHLHFCQUErQixPQUFWRSxRQUFRLEdBQUU7d0JBQy9DcEMsSUFBSUcsU0FBUzt3QkFDYkgsSUFBSXdDLEdBQUcsQ0FBQ0YsU0FBU0MsU0FBUyxHQUFHLEdBQUdsRCxLQUFLb0QsRUFBRSxHQUFHO3dCQUMxQ3pDLElBQUkwQyxJQUFJO29CQUNWO29CQUVBLDRCQUE0QjtvQkFDNUIsSUFBSyxJQUFJdkQsSUFBSSxHQUFHQSxJQUFJcUIsVUFBVUUsTUFBTSxFQUFFdkIsSUFBSzt3QkFDekMsTUFBTXdELElBQUluQyxTQUFTLENBQUNyQixFQUFFO3dCQUV0QixrQ0FBa0M7d0JBQ2xDLElBQUlwQixTQUFTbUIsT0FBTyxDQUFDaEIsTUFBTSxFQUFFOzRCQUMzQixNQUFNbUQsS0FBS3RELFNBQVNtQixPQUFPLENBQUNsQixDQUFDLEdBQUcyRSxFQUFFM0UsQ0FBQzs0QkFDbkMsTUFBTXNELEtBQUt2RCxTQUFTbUIsT0FBTyxDQUFDakIsQ0FBQyxHQUFHMEUsRUFBRTFFLENBQUM7NEJBQ25DLE1BQU1zRCxXQUFXbEMsS0FBS21DLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0E7NEJBRTFDLElBQUlDLFdBQVdwRCxPQUFPVyxvQkFBb0IsRUFBRTtnQ0FDMUMsTUFBTThELFFBQVEsQ0FBQ3pFLE9BQU9XLG9CQUFvQixHQUFHeUMsUUFBTyxJQUFLcEQsT0FBT1csb0JBQW9CO2dDQUNwRjZELEVBQUVqRCxNQUFNLElBQUkyQixLQUFLdUIsUUFBUXpFLE9BQU9ZLHNCQUFzQixHQUFHO2dDQUN6RDRELEVBQUVoRCxNQUFNLElBQUkyQixLQUFLc0IsUUFBUXpFLE9BQU9ZLHNCQUFzQixHQUFHOzRCQUMzRDt3QkFDRjt3QkFFQSxxQkFBcUI7d0JBQ3JCLE1BQU04RCxXQUFXO3dCQUNqQixNQUFNQyxRQUFRekQsS0FBS21DLElBQUksQ0FBQ21CLEVBQUVqRCxNQUFNLEdBQUdpRCxFQUFFakQsTUFBTSxHQUFHaUQsRUFBRWhELE1BQU0sR0FBR2dELEVBQUVoRCxNQUFNO3dCQUNqRSxJQUFJbUQsUUFBUUQsVUFBVTs0QkFDcEJGLEVBQUVqRCxNQUFNLEdBQUcsRUFBR0EsTUFBTSxHQUFHb0QsUUFBU0Q7NEJBQ2hDRixFQUFFaEQsTUFBTSxHQUFHLEVBQUdBLE1BQU0sR0FBR21ELFFBQVNEO3dCQUNsQzt3QkFFQSxrQkFBa0I7d0JBQ2xCRixFQUFFM0UsQ0FBQyxJQUFJMkUsRUFBRWpELE1BQU07d0JBQ2ZpRCxFQUFFMUUsQ0FBQyxJQUFJMEUsRUFBRWhELE1BQU07d0JBRWYsNkJBQTZCO3dCQUM3QixJQUFJZ0QsRUFBRTNFLENBQUMsR0FBRyxHQUFHOzRCQUNYMkUsRUFBRTNFLENBQUMsR0FBRzs0QkFDTjJFLEVBQUVqRCxNQUFNLElBQUksQ0FBQzt3QkFDZixPQUFPLElBQUlpRCxFQUFFM0UsQ0FBQyxHQUFHaUIsT0FBT00sS0FBSyxFQUFFOzRCQUM3Qm9ELEVBQUUzRSxDQUFDLEdBQUdpQixPQUFPTSxLQUFLOzRCQUNsQm9ELEVBQUVqRCxNQUFNLElBQUksQ0FBQzt3QkFDZjt3QkFFQSxJQUFJaUQsRUFBRTFFLENBQUMsR0FBRyxHQUFHOzRCQUNYMEUsRUFBRTFFLENBQUMsR0FBRzs0QkFDTjBFLEVBQUVoRCxNQUFNLElBQUksQ0FBQzt3QkFDZixPQUFPLElBQUlnRCxFQUFFMUUsQ0FBQyxHQUFHZ0IsT0FBT08sTUFBTSxFQUFFOzRCQUM5Qm1ELEVBQUUxRSxDQUFDLEdBQUdnQixPQUFPTyxNQUFNOzRCQUNuQm1ELEVBQUVoRCxNQUFNLElBQUksQ0FBQzt3QkFDZjt3QkFFQSxpQkFBaUI7d0JBQ2pCZ0QsRUFBRWpELE1BQU0sSUFBSTt3QkFDWmlELEVBQUVoRCxNQUFNLElBQUk7d0JBRVosZ0JBQWdCO3dCQUNoQixNQUFNRixPQUFPa0QsRUFBRWxELElBQUk7d0JBQ25CLE1BQU1zRCxXQUFXL0MsSUFBSWdELG9CQUFvQixDQUFDTCxFQUFFM0UsQ0FBQyxFQUFFMkUsRUFBRTFFLENBQUMsRUFBRSxHQUFHMEUsRUFBRTNFLENBQUMsRUFBRTJFLEVBQUUxRSxDQUFDLEVBQUV3QixPQUFPO3dCQUN4RXNELFNBQVNFLFlBQVksQ0FBQyxHQUFHLG1CQUE2QixPQUFWTixFQUFFL0MsT0FBTyxFQUFDO3dCQUN0RG1ELFNBQVNFLFlBQVksQ0FBQyxHQUFHO3dCQUV6QmpELElBQUlrQyxTQUFTLEdBQUdhO3dCQUNoQi9DLElBQUlHLFNBQVM7d0JBQ2JILElBQUl3QyxHQUFHLENBQUNHLEVBQUUzRSxDQUFDLEVBQUUyRSxFQUFFMUUsQ0FBQyxFQUFFd0IsT0FBTyxHQUFHLEdBQUdKLEtBQUtvRCxFQUFFLEdBQUc7d0JBQ3pDekMsSUFBSTBDLElBQUk7d0JBRVIsdUJBQXVCO3dCQUN2QjFDLElBQUlrQyxTQUFTLEdBQUcsbUJBQWlDLE9BQWRTLEVBQUUvQyxPQUFPLEdBQUcsR0FBRTt3QkFDakRJLElBQUlHLFNBQVM7d0JBQ2JILElBQUl3QyxHQUFHLENBQUNHLEVBQUUzRSxDQUFDLEVBQUUyRSxFQUFFMUUsQ0FBQyxFQUFFd0IsTUFBTSxHQUFHSixLQUFLb0QsRUFBRSxHQUFHO3dCQUNyQ3pDLElBQUkwQyxJQUFJO29CQUNWO29CQUVBOUUsZUFBZXNCLE9BQU8sR0FBRytDLHNCQUFzQkY7Z0JBQ2pEOztZQUVBbkUsZUFBZXNCLE9BQU8sR0FBRytDLHNCQUFzQkY7UUFDakQ7eUNBQ0E7UUFBQzVEO1FBQVE0QjtRQUFVUTtLQUFrQjtJQUd2Q2pELGdEQUFTQTsrQkFBQztZQUNSLE1BQU0yQixTQUFTdEIsVUFBVXVCLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsTUFBTWUsTUFBTWYsT0FBT2lFLFVBQVUsQ0FBQztZQUM5QixJQUFJLENBQUNsRCxLQUFLO1lBRVYsdUNBQXVDO1lBQ3ZDLE1BQU1tRDtvREFBZTtvQkFDbkIsTUFBTUMsTUFBTTFGLG1CQUFtQixJQUFJMkYsT0FBT0MsZ0JBQWdCLElBQUk7b0JBQzlELE1BQU1DLE9BQU90RSxPQUFPdUUscUJBQXFCO29CQUV6Q3ZFLE9BQU9NLEtBQUssR0FBR2dFLEtBQUtoRSxLQUFLLEdBQUc2RDtvQkFDNUJuRSxPQUFPTyxNQUFNLEdBQUcrRCxLQUFLL0QsTUFBTSxHQUFHNEQ7b0JBQzlCbkUsT0FBT3dFLEtBQUssQ0FBQ2xFLEtBQUssR0FBR2dFLEtBQUtoRSxLQUFLLEdBQUc7b0JBQ2xDTixPQUFPd0UsS0FBSyxDQUFDakUsTUFBTSxHQUFHK0QsS0FBSy9ELE1BQU0sR0FBRztvQkFFcENRLElBQUkwRCxLQUFLLENBQUNOLEtBQUtBO29CQUNmcEUsY0FBY0M7Z0JBQ2hCOztZQUVBLG9CQUFvQjtZQUNwQixNQUFNMEU7dURBQWtCLENBQUNDO29CQUN2QixNQUFNTCxPQUFPdEUsT0FBT3VFLHFCQUFxQjtvQkFDekN6RixTQUFTbUIsT0FBTyxHQUFHO3dCQUNqQmxCLEdBQUc0RixFQUFFQyxPQUFPLEdBQUdOLEtBQUtPLElBQUk7d0JBQ3hCN0YsR0FBRzJGLEVBQUVHLE9BQU8sR0FBR1IsS0FBS1MsR0FBRzt3QkFDdkI5RixRQUFRO29CQUNWO2dCQUNGOztZQUVBLE1BQU0rRjt3REFBbUI7b0JBQ3ZCbEcsU0FBU21CLE9BQU8sQ0FBQ2hCLE1BQU0sR0FBRztnQkFDNUI7O1lBRUFlLE9BQU9pRixnQkFBZ0IsQ0FBQyxhQUFhUDtZQUNyQzFFLE9BQU9pRixnQkFBZ0IsQ0FBQyxjQUFjRDtZQUN0Q2hGLE9BQU9pRixnQkFBZ0IsQ0FBQzt1Q0FBYztvQkFDcENuRyxTQUFTbUIsT0FBTyxDQUFDaEIsTUFBTSxHQUFHO2dCQUM1Qjs7WUFFQSwrQkFBK0I7WUFDL0IsTUFBTWlHO3VEQUFrQixDQUFDUDtvQkFDdkIsSUFBSUEsRUFBRVEsT0FBTyxDQUFDMUQsTUFBTSxHQUFHLEdBQUc7d0JBQ3hCLE1BQU02QyxPQUFPdEUsT0FBT3VFLHFCQUFxQjt3QkFDekN6RixTQUFTbUIsT0FBTyxHQUFHOzRCQUNqQmxCLEdBQUc0RixFQUFFUSxPQUFPLENBQUMsRUFBRSxDQUFDUCxPQUFPLEdBQUdOLEtBQUtPLElBQUk7NEJBQ25DN0YsR0FBRzJGLEVBQUVRLE9BQU8sQ0FBQyxFQUFFLENBQUNMLE9BQU8sR0FBR1IsS0FBS1MsR0FBRzs0QkFDbEM5RixRQUFRO3dCQUNWO29CQUNGO2dCQUNGOztZQUVBLE1BQU1tRztzREFBaUI7b0JBQ3JCdEcsU0FBU21CLE9BQU8sQ0FBQ2hCLE1BQU0sR0FBRztnQkFDNUI7O1lBRUFlLE9BQU9pRixnQkFBZ0IsQ0FBQyxhQUFhQztZQUNyQ2xGLE9BQU9pRixnQkFBZ0IsQ0FBQyxZQUFZRztZQUVwQ2xCO1lBQ0F2QixRQUFRM0MsUUFBUWU7WUFFaEIsMkJBQTJCO1lBQzNCLElBQUlzRTtZQUNKLE1BQU1DO29EQUFlO29CQUNuQkMsYUFBYUY7b0JBQ2JBLGdCQUFnQkcsV0FBV3RCLGNBQWM7Z0JBQzNDOztZQUVBRSxPQUFPYSxnQkFBZ0IsQ0FBQyxVQUFVSztZQUVsQzt1Q0FBTztvQkFDTCxJQUFJM0csZUFBZXNCLE9BQU8sRUFBRTt3QkFDMUJ3RixxQkFBcUI5RyxlQUFlc0IsT0FBTztvQkFDN0M7b0JBQ0FzRixhQUFhRjtvQkFDYmpCLE9BQU9zQixtQkFBbUIsQ0FBQyxVQUFVSjtvQkFDckN0RixPQUFPMEYsbUJBQW1CLENBQUMsYUFBYWhCO29CQUN4QzFFLE9BQU8wRixtQkFBbUIsQ0FBQyxjQUFjVjtvQkFDekNoRixPQUFPMEYsbUJBQW1CLENBQUMsYUFBYVI7b0JBQ3hDbEYsT0FBTzBGLG1CQUFtQixDQUFDLFlBQVlOO2dCQUN6Qzs7UUFDRjs4QkFBRztRQUFDekM7UUFBUzVDO1FBQWV0QjtLQUFpQjtJQUU3QyxxQkFDRSw4REFBQ3VCO1FBQ0MyRixLQUFLakg7UUFDTGtILFdBQVU7UUFDVnBCLE9BQU87WUFDTGxFLE9BQU87WUFDUEMsUUFBUTtZQUNSc0YsWUFBWTtZQUNaQyxlQUFlO1FBQ2pCOzs7Ozs7QUFHTjtHQS9Vd0J0SDtLQUFBQSIsInNvdXJjZXMiOlsiRDpcXHBvcnRmb2xpb1xcc3JjXFxjb21wb25lbnRzXFxjeWJlci1ncmlkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCJcclxuXHJcbmludGVyZmFjZSBDeWJlckdyaWRQcm9wcyB7XHJcbiAgaXNMb3dQZXJmb3JtYW5jZT86IGJvb2xlYW5cclxufVxyXG5cclxuaW50ZXJmYWNlIFBhcnRpY2xlIHtcclxuICB4OiBudW1iZXJcclxuICB5OiBudW1iZXJcclxuICBzaXplOiBudW1iZXJcclxuICBzcGVlZFg6IG51bWJlclxyXG4gIHNwZWVkWTogbnVtYmVyXHJcbiAgb3BhY2l0eTogbnVtYmVyXHJcbiAgY29ubmVjdGlvbjogbnVtYmVyXHJcbn1cclxuXHJcbmludGVyZmFjZSBDb25uZWN0aW9uIHtcclxuICBmcm9tOiBudW1iZXJcclxuICB0bzogbnVtYmVyXHJcbiAgbGlmZTogbnVtYmVyXHJcbiAgbWF4TGlmZTogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN5YmVyR3JpZCh7IGlzTG93UGVyZm9ybWFuY2UgPSBmYWxzZSB9OiBDeWJlckdyaWRQcm9wcykge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcclxuICBjb25zdCBhbmltYXRpb25JZFJlZiA9IHVzZVJlZjxudW1iZXI+KClcclxuICBjb25zdCBwYXJ0aWNsZXNSZWYgPSB1c2VSZWY8UGFydGljbGVbXT4oW10pXHJcbiAgY29uc3QgY29ubmVjdGlvbnNSZWYgPSB1c2VSZWY8Q29ubmVjdGlvbltdPihbXSlcclxuICBjb25zdCBtb3VzZVJlZiA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIGFjdGl2ZTogZmFsc2UgfSlcclxuXHJcbiAgLy8gUGVyZm9ybWFuY2UtYmFzZWQgY29uZmlndXJhdGlvblxyXG4gIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgIHBhcnRpY2xlQ291bnQ6IGlzTG93UGVyZm9ybWFuY2UgPyAzMCA6IDYwLFxyXG4gICAgZ3JpZFNpemU6IGlzTG93UGVyZm9ybWFuY2UgPyA0MCA6IDMwLFxyXG4gICAgcGFydGljbGVTaXplOiBpc0xvd1BlcmZvcm1hbmNlID8geyBtaW46IDEsIG1heDogMiB9IDogeyBtaW46IDEsIG1heDogMyB9LFxyXG4gICAgY29ubmVjdGlvbkRpc3RhbmNlOiBpc0xvd1BlcmZvcm1hbmNlID8gMTUwIDogMjAwLFxyXG4gICAgY29ubmVjdGlvbk1heENvdW50OiBpc0xvd1BlcmZvcm1hbmNlID8gMiA6IDMsXHJcbiAgICBmYWRlT3BhY2l0eTogaXNMb3dQZXJmb3JtYW5jZSA/IDAuMiA6IDAuMSxcclxuICAgIG1heEZQUzogaXNMb3dQZXJmb3JtYW5jZSA/IDMwIDogNjAsXHJcbiAgICBwYXJ0aWNsZVNwZWVkOiBpc0xvd1BlcmZvcm1hbmNlID8gMC4zIDogMC41LFxyXG4gICAgbW91c2VJbmZsdWVuY2VSYWRpdXM6IDE1MCxcclxuICAgIG1vdXNlSW5mbHVlbmNlU3RyZW5ndGg6IDAuNSxcclxuICB9XHJcblxyXG4gIGNvbnN0IGluaXRQYXJ0aWNsZXMgPSB1c2VDYWxsYmFjayhcclxuICAgIChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50ID0gW11cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcucGFydGljbGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgcGFydGljbGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGNhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgICBzaXplOiBNYXRoLnJhbmRvbSgpICogKGNvbmZpZy5wYXJ0aWNsZVNpemUubWF4IC0gY29uZmlnLnBhcnRpY2xlU2l6ZS5taW4pICsgY29uZmlnLnBhcnRpY2xlU2l6ZS5taW4sXHJcbiAgICAgICAgICBzcGVlZFg6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGNvbmZpZy5wYXJ0aWNsZVNwZWVkLFxyXG4gICAgICAgICAgc3BlZWRZOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBjb25maWcucGFydGljbGVTcGVlZCxcclxuICAgICAgICAgIG9wYWNpdHk6IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjIsXHJcbiAgICAgICAgICBjb25uZWN0aW9uOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb25maWcuY29ubmVjdGlvbk1heENvdW50KSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGNvbm5lY3Rpb25zUmVmLmN1cnJlbnQgPSBbXVxyXG4gICAgfSxcclxuICAgIFtjb25maWcuY29ubmVjdGlvbk1heENvdW50XSxcclxuICApXHJcblxyXG4gIGNvbnN0IGRyYXdHcmlkID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLCAyNTUsIDAsIDAuMSlcIlxyXG4gICAgICBjdHgubGluZVdpZHRoID0gMC41XHJcblxyXG4gICAgICAvLyBEcmF3IHZlcnRpY2FsIGxpbmVzXHJcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4ICs9IGNvbmZpZy5ncmlkU2l6ZSkge1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgMClcclxuICAgICAgICBjdHgubGluZVRvKHgsIGhlaWdodClcclxuICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBob3Jpem9udGFsIGxpbmVzXHJcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IGhlaWdodDsgeSArPSBjb25maWcuZ3JpZFNpemUpIHtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHgubW92ZVRvKDAsIHkpXHJcbiAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgeSlcclxuICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtjb25maWcuZ3JpZFNpemVdLFxyXG4gIClcclxuXHJcbiAgY29uc3QgdXBkYXRlQ29ubmVjdGlvbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNSZWYuY3VycmVudFxyXG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBjb25uZWN0aW9uc1JlZi5jdXJyZW50XHJcblxyXG4gICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNvbm5lY3Rpb25zXHJcbiAgICBmb3IgKGxldCBpID0gY29ubmVjdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29ubmVjdGlvbnNbaV0ubGlmZS0tXHJcbiAgICAgIGlmIChjb25uZWN0aW9uc1tpXS5saWZlIDw9IDApIHtcclxuICAgICAgICBjb25uZWN0aW9ucy5zcGxpY2UoaSwgMSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBuZXcgY29ubmVjdGlvbnNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHAxID0gcGFydGljbGVzW2ldXHJcblxyXG4gICAgICAvLyBDb3VudCBjdXJyZW50IGNvbm5lY3Rpb25zIGZvciB0aGlzIHBhcnRpY2xlXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zLmZpbHRlcigoYykgPT4gYy5mcm9tID09PSBpIHx8IGMudG8gPT09IGkpLmxlbmd0aFxyXG5cclxuICAgICAgaWYgKGN1cnJlbnRDb25uZWN0aW9ucyA8IHAxLmNvbm5lY3Rpb24pIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBwYXJ0aWNsZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IHAyID0gcGFydGljbGVzW2pdXHJcbiAgICAgICAgICBjb25zdCBkeCA9IHAxLnggLSBwMi54XHJcbiAgICAgICAgICBjb25zdCBkeSA9IHAxLnkgLSBwMi55XHJcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcclxuXHJcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBjb25maWcuY29ubmVjdGlvbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY29ubmVjdGlvbiBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXhpc3RzID0gY29ubmVjdGlvbnMuc29tZShcclxuICAgICAgICAgICAgICAoYykgPT4gKGMuZnJvbSA9PT0gaSAmJiBjLnRvID09PSBqKSB8fCAoYy5mcm9tID09PSBqICYmIGMudG8gPT09IGkpLFxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25FeGlzdHMpIHtcclxuICAgICAgICAgICAgICBjb25zdCBtYXhMaWZlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjAwKSArIDEwMFxyXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgZnJvbTogaSxcclxuICAgICAgICAgICAgICAgIHRvOiBqLFxyXG4gICAgICAgICAgICAgICAgbGlmZTogbWF4TGlmZSxcclxuICAgICAgICAgICAgICAgIG1heExpZmU6IG1heExpZmUsXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW2NvbmZpZy5jb25uZWN0aW9uRGlzdGFuY2VdKVxyXG5cclxuICBjb25zdCBhbmltYXRlID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpID0+IHtcclxuICAgICAgbGV0IGxhc3RUaW1lID0gMFxyXG4gICAgICBjb25zdCB0YXJnZXRGcmFtZVRpbWUgPSAxMDAwIC8gY29uZmlnLm1heEZQU1xyXG5cclxuICAgICAgY29uc3QgZnJhbWUgPSAoY3VycmVudFRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAtIGxhc3RUaW1lIDwgdGFyZ2V0RnJhbWVUaW1lKSB7XHJcbiAgICAgICAgICBhbmltYXRpb25JZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RUaW1lID0gY3VycmVudFRpbWVcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggZmFkZSBlZmZlY3RcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoMCwgMCwgMCwgJHtjb25maWcuZmFkZU9wYWNpdHl9KWBcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxyXG5cclxuICAgICAgICAvLyBEcmF3IGdyaWRcclxuICAgICAgICBkcmF3R3JpZChjdHgsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFuZCBkcmF3IGNvbm5lY3Rpb25zXHJcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbnMoKVxyXG5cclxuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zUmVmLmN1cnJlbnRcclxuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNSZWYuY3VycmVudFxyXG5cclxuICAgICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zXHJcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKSB7XHJcbiAgICAgICAgICBjb25zdCBwMSA9IHBhcnRpY2xlc1tjb25uZWN0aW9uLmZyb21dXHJcbiAgICAgICAgICBjb25zdCBwMiA9IHBhcnRpY2xlc1tjb25uZWN0aW9uLnRvXVxyXG5cclxuICAgICAgICAgIGNvbnN0IGFscGhhID0gKGNvbm5lY3Rpb24ubGlmZSAvIGNvbm5lY3Rpb24ubWF4TGlmZSkgKiAwLjhcclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGByZ2JhKDAsIDI1NSwgMCwgJHthbHBoYX0pYFxyXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDFcclxuXHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSlcclxuICAgICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSlcclxuICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAgIC8vIERyYXcgZGF0YSBwYWNrZXQgbW92aW5nIGFsb25nIHRoZSBjb25uZWN0aW9uXHJcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IDEgLSBjb25uZWN0aW9uLmxpZmUgLyBjb25uZWN0aW9uLm1heExpZmVcclxuICAgICAgICAgIGNvbnN0IHBhY2tldFggPSBwMS54ICsgKHAyLnggLSBwMS54KSAqIHByb2dyZXNzXHJcbiAgICAgICAgICBjb25zdCBwYWNrZXRZID0gcDEueSArIChwMi55IC0gcDEueSkgKiBwcm9ncmVzc1xyXG5cclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBgcmdiYSgwLCAyNTUsIDI1NSwgJHthbHBoYSAqIDJ9KWBcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgY3R4LmFyYyhwYWNrZXRYLCBwYWNrZXRZLCAyLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbmQgZHJhdyBwYXJ0aWNsZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgcCA9IHBhcnRpY2xlc1tpXVxyXG5cclxuICAgICAgICAgIC8vIEFwcGx5IG1vdXNlIGluZmx1ZW5jZSBpZiBhY3RpdmVcclxuICAgICAgICAgIGlmIChtb3VzZVJlZi5jdXJyZW50LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBkeCA9IG1vdXNlUmVmLmN1cnJlbnQueCAtIHAueFxyXG4gICAgICAgICAgICBjb25zdCBkeSA9IG1vdXNlUmVmLmN1cnJlbnQueSAtIHAueVxyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGNvbmZpZy5tb3VzZUluZmx1ZW5jZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGZvcmNlID0gKGNvbmZpZy5tb3VzZUluZmx1ZW5jZVJhZGl1cyAtIGRpc3RhbmNlKSAvIGNvbmZpZy5tb3VzZUluZmx1ZW5jZVJhZGl1c1xyXG4gICAgICAgICAgICAgIHAuc3BlZWRYICs9IGR4ICogZm9yY2UgKiBjb25maWcubW91c2VJbmZsdWVuY2VTdHJlbmd0aCAqIDAuMDFcclxuICAgICAgICAgICAgICBwLnNwZWVkWSArPSBkeSAqIGZvcmNlICogY29uZmlnLm1vdXNlSW5mbHVlbmNlU3RyZW5ndGggKiAwLjAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBcHBseSBzcGVlZCBsaW1pdHNcclxuICAgICAgICAgIGNvbnN0IG1heFNwZWVkID0gMlxyXG4gICAgICAgICAgY29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQocC5zcGVlZFggKiBwLnNwZWVkWCArIHAuc3BlZWRZICogcC5zcGVlZFkpXHJcbiAgICAgICAgICBpZiAoc3BlZWQgPiBtYXhTcGVlZCkge1xyXG4gICAgICAgICAgICBwLnNwZWVkWCA9IChwLnNwZWVkWCAvIHNwZWVkKSAqIG1heFNwZWVkXHJcbiAgICAgICAgICAgIHAuc3BlZWRZID0gKHAuc3BlZWRZIC8gc3BlZWQpICogbWF4U3BlZWRcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb25cclxuICAgICAgICAgIHAueCArPSBwLnNwZWVkWFxyXG4gICAgICAgICAgcC55ICs9IHAuc3BlZWRZXHJcblxyXG4gICAgICAgICAgLy8gQm91bmRhcnkgY2hlY2sgd2l0aCBib3VuY2VcclxuICAgICAgICAgIGlmIChwLnggPCAwKSB7XHJcbiAgICAgICAgICAgIHAueCA9IDBcclxuICAgICAgICAgICAgcC5zcGVlZFggKj0gLTFcclxuICAgICAgICAgIH0gZWxzZSBpZiAocC54ID4gY2FudmFzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIHAueCA9IGNhbnZhcy53aWR0aFxyXG4gICAgICAgICAgICBwLnNwZWVkWCAqPSAtMVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChwLnkgPCAwKSB7XHJcbiAgICAgICAgICAgIHAueSA9IDBcclxuICAgICAgICAgICAgcC5zcGVlZFkgKj0gLTFcclxuICAgICAgICAgIH0gZWxzZSBpZiAocC55ID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgICAgICBwLnkgPSBjYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgICAgIHAuc3BlZWRZICo9IC0xXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgZnJpY3Rpb25cclxuICAgICAgICAgIHAuc3BlZWRYICo9IDAuOTlcclxuICAgICAgICAgIHAuc3BlZWRZICo9IDAuOTlcclxuXHJcbiAgICAgICAgICAvLyBEcmF3IHBhcnRpY2xlXHJcbiAgICAgICAgICBjb25zdCBzaXplID0gcC5zaXplXHJcbiAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwLngsIHAueSwgMCwgcC54LCBwLnksIHNpemUgKiAyKVxyXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGByZ2JhKDAsIDI1NSwgMCwgJHtwLm9wYWNpdHl9KWApXHJcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDAsIDI1NSwgMCwgMClcIilcclxuXHJcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnRcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgY3R4LmFyYyhwLngsIHAueSwgc2l6ZSAqIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgICAgY3R4LmZpbGwoKVxyXG5cclxuICAgICAgICAgIC8vIENvcmUgb2YgdGhlIHBhcnRpY2xlXHJcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoMCwgMjU1LCAwLCAke3Aub3BhY2l0eSAqIDJ9KWBcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgY3R4LmFyYyhwLngsIHAueSwgc2l6ZSwgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbmltYXRpb25JZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBhbmltYXRpb25JZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKVxyXG4gICAgfSxcclxuICAgIFtjb25maWcsIGRyYXdHcmlkLCB1cGRhdGVDb25uZWN0aW9uc10sXHJcbiAgKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcclxuICAgIGlmICghY2FudmFzKSByZXR1cm5cclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuXHJcblxyXG4gICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIHdpbmRvdyBzaXplXHJcbiAgICBjb25zdCByZXNpemVDYW52YXMgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRwciA9IGlzTG93UGVyZm9ybWFuY2UgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMVxyXG4gICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblxyXG4gICAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoICogZHByXHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodCAqIGRwclxyXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSByZWN0LndpZHRoICsgXCJweFwiXHJcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSByZWN0LmhlaWdodCArIFwicHhcIlxyXG5cclxuICAgICAgY3R4LnNjYWxlKGRwciwgZHByKVxyXG4gICAgICBpbml0UGFydGljbGVzKGNhbnZhcylcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3VzZSBpbnRlcmFjdGlvblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICBtb3VzZVJlZi5jdXJyZW50ID0ge1xyXG4gICAgICAgIHg6IGUuY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgICAgICB5OiBlLmNsaWVudFkgLSByZWN0LnRvcCxcclxuICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICBtb3VzZVJlZi5jdXJyZW50LmFjdGl2ZSA9IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xyXG4gICAgICBtb3VzZVJlZi5jdXJyZW50LmFjdGl2ZSA9IHRydWVcclxuICAgIH0pXHJcblxyXG4gICAgLy8gVG91Y2ggaW50ZXJhY3Rpb24gZm9yIG1vYmlsZVxyXG4gICAgY29uc3QgaGFuZGxlVG91Y2hNb3ZlID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgIG1vdXNlUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgICB4OiBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgICAgICAgIHk6IGUudG91Y2hlc1swXS5jbGllbnRZIC0gcmVjdC50b3AsXHJcbiAgICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVG91Y2hFbmQgPSAoKSA9PiB7XHJcbiAgICAgIG1vdXNlUmVmLmN1cnJlbnQuYWN0aXZlID0gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBoYW5kbGVUb3VjaE1vdmUpXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGhhbmRsZVRvdWNoRW5kKVxyXG5cclxuICAgIHJlc2l6ZUNhbnZhcygpXHJcbiAgICBhbmltYXRlKGNhbnZhcywgY3R4KVxyXG5cclxuICAgIC8vIFRocm90dGxlZCByZXNpemUgaGFuZGxlclxyXG4gICAgbGV0IHJlc2l6ZVRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0XHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lb3V0KVxyXG4gICAgICByZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChyZXNpemVDYW52YXMsIDI1MClcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvbklkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZFJlZi5jdXJyZW50KVxyXG4gICAgICB9XHJcbiAgICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lb3V0KVxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpXHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSlcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpXHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGhhbmRsZVRvdWNoTW92ZSlcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoYW5kbGVUb3VjaEVuZClcclxuICAgIH1cclxuICB9LCBbYW5pbWF0ZSwgaW5pdFBhcnRpY2xlcywgaXNMb3dQZXJmb3JtYW5jZV0pXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIHotMCB3LWZ1bGwgaC1mdWxsXCJcclxuICAgICAgc3R5bGU9e3tcclxuICAgICAgICB3aWR0aDogXCIxMDB2d1wiLFxyXG4gICAgICAgIGhlaWdodDogXCIxMDB2aFwiLFxyXG4gICAgICAgIHdpbGxDaGFuZ2U6IFwidHJhbnNmb3JtXCIsXHJcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCIsIC8vIEVuYWJsZSBtb3VzZSBpbnRlcmFjdGlvblxyXG4gICAgICB9fVxyXG4gICAgLz5cclxuICApXHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwiQ3liZXJHcmlkIiwiaXNMb3dQZXJmb3JtYW5jZSIsImNhbnZhc1JlZiIsImFuaW1hdGlvbklkUmVmIiwicGFydGljbGVzUmVmIiwiY29ubmVjdGlvbnNSZWYiLCJtb3VzZVJlZiIsIngiLCJ5IiwiYWN0aXZlIiwiY29uZmlnIiwicGFydGljbGVDb3VudCIsImdyaWRTaXplIiwicGFydGljbGVTaXplIiwibWluIiwibWF4IiwiY29ubmVjdGlvbkRpc3RhbmNlIiwiY29ubmVjdGlvbk1heENvdW50IiwiZmFkZU9wYWNpdHkiLCJtYXhGUFMiLCJwYXJ0aWNsZVNwZWVkIiwibW91c2VJbmZsdWVuY2VSYWRpdXMiLCJtb3VzZUluZmx1ZW5jZVN0cmVuZ3RoIiwiaW5pdFBhcnRpY2xlcyIsImNhbnZhcyIsImN1cnJlbnQiLCJpIiwicHVzaCIsIk1hdGgiLCJyYW5kb20iLCJ3aWR0aCIsImhlaWdodCIsInNpemUiLCJzcGVlZFgiLCJzcGVlZFkiLCJvcGFjaXR5IiwiY29ubmVjdGlvbiIsImZsb29yIiwiZHJhd0dyaWQiLCJjdHgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsInVwZGF0ZUNvbm5lY3Rpb25zIiwicGFydGljbGVzIiwiY29ubmVjdGlvbnMiLCJsZW5ndGgiLCJsaWZlIiwic3BsaWNlIiwicDEiLCJjdXJyZW50Q29ubmVjdGlvbnMiLCJmaWx0ZXIiLCJjIiwiZnJvbSIsInRvIiwiaiIsInAyIiwiZHgiLCJkeSIsImRpc3RhbmNlIiwic3FydCIsImNvbm5lY3Rpb25FeGlzdHMiLCJzb21lIiwibWF4TGlmZSIsImFuaW1hdGUiLCJsYXN0VGltZSIsInRhcmdldEZyYW1lVGltZSIsImZyYW1lIiwiY3VycmVudFRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImFscGhhIiwicHJvZ3Jlc3MiLCJwYWNrZXRYIiwicGFja2V0WSIsImFyYyIsIlBJIiwiZmlsbCIsInAiLCJmb3JjZSIsIm1heFNwZWVkIiwic3BlZWQiLCJncmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZ2V0Q29udGV4dCIsInJlc2l6ZUNhbnZhcyIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic3R5bGUiLCJzY2FsZSIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJoYW5kbGVNb3VzZUxlYXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVRvdWNoTW92ZSIsInRvdWNoZXMiLCJoYW5kbGVUb3VjaEVuZCIsInJlc2l6ZVRpbWVvdXQiLCJoYW5kbGVSZXNpemUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVmIiwiY2xhc3NOYW1lIiwid2lsbENoYW5nZSIsInBvaW50ZXJFdmVudHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/cyber-grid.tsx\n"));

/***/ })

});